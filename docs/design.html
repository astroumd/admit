<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Design Overview &#8212; ADMIT 1.0.6 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="ADMIT 1.0.6 documentation" href="index.html" />
    <link rel="next" title="Documentation Style Guide" href="style.html" />
    <link rel="prev" title="Installation Guide" href="installguide.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="style.html" title="Documentation Style Guide"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="installguide.html" title="Installation Guide"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">ADMIT 1.0.6 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="design-overview">
<h1>Design Overview<a class="headerlink" href="#design-overview" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p id="intro">The ALMA Data Mining Toolkit (ADMIT) is a value-added software package
which integrates with the ALMA archive and CASA to provide scientists with
quick access to traditional science data products such as moment maps,
as well as with new innovative tools for exploring data cubes and their many
derived products. The goals of the
package are to:</p>
<ol class="arabic simple">
<li>make the scientific value of ALMA data more immediate to all users;</li>
<li>create an analysis infrastructure that allows users to build new tools;</li>
<li>provide new types of tools for mining the science in ALMA data;</li>
<li>increase the scientific value of the rich data archive that ALMA is
creating; and</li>
<li>re-execute and explore the robustness of the initial pipeline results.</li>
</ol>
<p>For each ALMA science project a set of science quality image cubes
exist. ADMIT runs a series of ADMIT Tasks (<a class="reference internal" href="#ats">ATs</a>), which are essentially
beefed up CASA tools/tasks, and produces a set of Basic Data Products
(<a class="reference internal" href="#bdps">BDPs</a>).  ADMIT provides a wrapper around these tasks for use within the
ALMA pipeline and to have a persistent state for re-execution later on by
the end user in ADMIT&#8217;s own pipeline.  ADMIT products are contained in
a compressed archive file, <cite>admit.zip</cite>, in parallel with the existing
Alma Data Products (ADPs). Examples of ADPs in a project are the
Raw Visibility Data (in ASDM format) and the Science Data Cubes (in FITS
format) for each target (source) and each band.</p>
<p>Once users have downloaded the ADMIT files, they can preview the work
the ALMA pipeline has created, without immediate need to download
the generally much larger ADPs. They will also be able to re-run selected
portions of the ADMIT pipeline from either the (casapy) commandline, or
a GUI, and compare and improve upon the pipeline-produced results. For
this, some of the ADPs may be needed.</p>
</div>
<div class="section" id="admit-tasks">
<h2>ADMIT Tasks<a class="headerlink" href="#admit-tasks" title="Permalink to this headline">¶</a></h2>
<p id="ats">An <a class="reference internal" href="module/admit/AT.html#at-base-api"><span class="std std-ref">Task &#8212; ADMIT task (AT) base.</span></a>
(AT) is made up of zero or more CASA tasks.  It takes as
input zero or more BDPs and produces one or more output BDPs.
BDPs are the data objects used to communicate results between tasks and to the
user. The BDPs output by an AT do not have to be of the same type. An AT also
has input parameters that control its detailed functionality. These parameters
may map directly to CASA task parameters or may be peculiar to the AT.  On
disk, ATs are stored as XML. In memory, each is stored in a specific class
representation derived from the <a class="reference internal" href="module/admit/AT.html#at-base-api"><span class="std std-ref">Task &#8212; ADMIT task (AT) base.</span></a> base class.  A user may have
multiple instantiations of any given AT type active in an ADMIT session,
avoiding the need to save and recall parameters for different invocations of a
task.  The <a class="reference internal" href="module/admit/FlowManager.html#flowmanager-api"><span class="std std-ref">Flow &#8212; Project task flow manager.</span></a>
keeps track of the connection order of any set of ATs (see <a class="reference internal" href="#workflow-management">Workflow
Management</a>).   AT parameters are validated only at runtime; there is
no validation on export to or import from XML. The representations of
all the ATs in a project are stored in a single XML file (admit.xml).</p>
</div>
<div class="section" id="basic-data-products">
<h2>Basic Data Products<a class="headerlink" href="#basic-data-products" title="Permalink to this headline">¶</a></h2>
<p id="bdps">A <a class="reference internal" href="module/admit.bdp/BDP.html#bdp-base-api"><span class="std std-ref">BDP &#8212; Basic data product base.</span></a> is the basic unit of storage for Admit. The BDPs are
initially created by an <a class="reference internal" href="module/admit/AT.html#at-base-api"><span class="std std-ref">Task &#8212; ADMIT task (AT) base.</span></a> (AT). As with ATs, the external
data format for BDPs is XML and in memory, BDPs are stored in a specific
class representation derived from the BDP base class. BDPs are also the unit
that is passed between ATs for processing. Specific BDP types are described
in the <a class="reference internal" href="#bdp-designs"><span class="std std-ref">Individual BDP Designs</span></a> section.</p>
</div>
<div class="section" id="the-admit-object">
<h2>The ADMIT object<a class="headerlink" href="#the-admit-object" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="admit-i-o-system">
<h2>ADMIT I/O System<a class="headerlink" href="#admit-i-o-system" title="Permalink to this headline">¶</a></h2>
<p id="io-system">The on disk storage of AMDIT, ATs, and BDPs is one or more XML files. All
AT and ADMIT data are stored in a master XML file (default is admit.xml).
BDP data are each stored in their own XML file, making them highly portable.
All XML data are validated against a document type definition
(DTD). Validation against a DTD ensures that the XML nodes required
to fully instantiate the system are present and contain valid values. Each
AT and BDP has its own DTD document, located in admit/xmlio/dtd.</p>
<p>The DTDs for each AT and BDP type are autogenerated directly from the
class definition in Python. The dtdGenerator is responsible for creating
all of the DTDs as well as some system files. It does this by scanning the
AT and BDP directories for files ending in _AT.py and _BDP.py. It then
creates an instance of each class, then through introspection generates
a list of class attributes and their types (float, int, etc.). The DTD
files are then created based on this list.</p>
<p>The DTD is also included in each BDP XML file so that the BDP definition is
completely self-contained.  This ensures
integrity against future changes to a BDP definition (i.e., versioning).
To allow for flexibility by end users (aka &#8220;tinkering&#8221;), extraneous nodes
not captured in the DTD will be ignored, but will not cause invalidation.
Data validation occurs on both write and read.</p>
<p>All XML work (I/O and validation) happens in the background and does not
have to be handled by the user or author of an AT. There in a general writing
class in the AT and BDP base classes that can handle any valid AT and BDP
structure.</p>
<p>The <a class="reference internal" href="module/admit.xmlio/Parser.html#parser-api"><span class="std std-ref">Parser &#8212; Converts an ADMIT project on disk to in-memory objects.</span></a> is a class that uses the SAX library to interpret the
XML contents.  Inside each AT and BDP XML node is an attribute that indicates
the type of AT/BDP the given XML describes. An instance of the appropriate
class is then instantiated and the DTD is used to verify each node as it is
read by the parser. The type of each node is recorded in the XML so that it
can be properly added to the class. For example:</p>
<div class="code xml highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">noise</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;FLOAT&quot;</span><span class="o">&gt;</span>
<span class="mf">3.255</span>
<span class="o">&lt;/</span><span class="n">noise</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>is converted to:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">BDP</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="mf">3.255</span>
</pre></div>
</div>
</div>
<div class="section" id="workflow-management">
<h2>Workflow Management<a class="headerlink" href="#workflow-management" title="Permalink to this headline">¶</a></h2>
<p id="workflow">We take a task-centric view of workflow in which an ADMIT Task (AT)
is an arbitrary M-to-N mapping of BDPs, possibly with additional
internal attributes and methods.  BDPs are passive
data containers, without parents or children, and are owned by the AT
which produces them. Hence, ATs also function as BDP containers.
The Flow Manager (FM) maintains a full list of ATs and how they are
connected, allowing it to keep all BDPs up to date as ATs are modified.</p>
<p>Conceptually, a connection maps the output(s) of one AT to the input(s) of another AT. The Flow Manager creates an overall connection map, where a single
connection is specified by a four-element tuple of integer indices:</p>
<p><span class="math">\((AT_{out},BDP_{out},AT_{in},BDP_{in})\)</span></p>
<p>In the case of a multiflow, the root AT components may contain an embedded
parent project index. Figure 1 illustrates the connection map concept, while
Figures 2 and 3 give an realistic example workflow and the resulting connection
map.</p>
<div class="figure align-center" id="id8">
<a class="reference internal image-reference" href="_images/connection.png"><img alt="Example Flow." src="_images/connection.png" style="width: 487.3px; height: 311.3px;" /></a>
<p class="caption"><span class="caption-text"><strong>Figure 1:</strong> The connection in this diagram connects two ATs, <cite>a1</cite> and <cite>a2</cite>,
inside a single project.   The output BDP of <cite>a1</cite> is an
input BDP of <cite>a2</cite>, i.e., <span class="math">\(b1 \equiv b2\)</span>.   A given output
BDP may be the input to an arbitrary number of ATs, but can be the
output one and only one AT. For a multiflow project, <cite>a1</cite> may embed a
project ID number.</span></p>
</div>
<div class="figure align-center" id="id9">
<a class="reference internal image-reference" href="_images/flow6-AT.png"><img alt="ADMIT Task connection example" src="_images/flow6-AT.png" style="width: 739.0px; height: 685.0px;" /></a>
<p class="caption"><span class="caption-text"><strong>Figure 2:</strong> Example realistic workflow with task connection map. A
FITS cube is ingested (a1) and processed through a number of tasks:
summary, statistics, spectral line cut out, moment. Integers along
the arrows indicate the output BDP index available to the next task
in the map.</span></p>
</div>
<div class="figure align-center" id="id10">
<a class="reference internal image-reference" href="_images/flow6-FM.png"><img alt="ADMIT Task connection example" src="_images/flow6-FM.png" style="width: 559.2px; height: 621.6px;" /></a>
<p class="caption"><span class="caption-text"><strong>Figure 3:</strong> The Flow Manager connection map and dependencies for the workflow in
Figure 2. The tuples in the connection map give the ADMIT
task and BDP output/input indices. The Flow Manager also computes
the dependence list of ATs so that a change in one AT will trigger
re-execution of ATs that depend on it in order to recompute the BDPs.</span></p>
</div>
</div>
<div class="section" id="architecture-overview">
<h2>Architecture Overview<a class="headerlink" href="#architecture-overview" title="Permalink to this headline">¶</a></h2>
<p id="architecture">Figure 4 is a schematic of the overall interaction
of ADMIT modules. Their functionality is described below.</p>
<div class="figure align-center" id="id11">
<a class="reference internal image-reference" href="_images/AdmitArchitecture.png"><img alt="Schematic of how ADMIT fits together." src="_images/AdmitArchitecture.png" style="width: 986.0px; height: 815.0px;" /></a>
<p class="caption"><span class="caption-text"><strong>Figure 4:</strong> Schematic of how ADMIT fits together.</span></p>
</div>
<div class="section" id="bdp-infrastructure">
<h3>BDP Infrastructure<a class="headerlink" href="#bdp-infrastructure" title="Permalink to this headline">¶</a></h3>
<p>The BDP Base Class contains methods and member variables common to all BDPS.
Individual BDPs derive from it and add their own special features.  BDP I/O
is built-in to the base class through Python XML libraries.</p>
</div>
<div class="section" id="task-infrastructure">
<h3>Task Infrastructure<a class="headerlink" href="#task-infrastructure" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><em>ADMIT Task Classes</em></dt>
<dd>An ADMIT Task Base Class allows one or more CASA tasks to be encapsulated
within one ADMIT Task.  The base class should indicate required methods and
member variables such that a user can write her own AT.  Individual ADMIT
Tasks derive from the ADMIT Task Base Class.</dd>
<dt><em>Task Test Suites</em></dt>
<dd>Each Task must have at least a unit test and integration test.</dd>
<dt><em>CASA Task library</em></dt>
<dd>From which ADMIT tasks may be built.</dd>
</dl>
</div>
<div class="section" id="utilities">
<h3>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h3>
<p>This ADMIT Function Library includes useful generic classes to handle
tables, plotting, and mathematical functions. Utilities will expand
as needed.</p>
</div>
<div class="section" id="toolkit-infrastructure">
<h3>Toolkit Infrastructure<a class="headerlink" href="#toolkit-infrastructure" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><em>Data Discovery/Export/Import</em></dt>
<dd>This is the module that examines the working directory recursively for
FITS files and ADMIT products.  It should be able to recognize vanilla,
ALMA-style, and VLA-style directory trees and branch accordingly.  It will
also handle the case of giving a self-contained subset of ADMIT products
to a collaborator. It would write a single compressed file containing
the ADMIT products in the appropriate hierarchy.</dd>
<dt><em>ADMIT Object</em></dt>
<dd>From the results of data discovery, the an ADMIT object is instantiated
in memory as well as setting up the initial workflow for an ADMIT run
(or re-run).  This initialization includes instantiation of any discovered
ATs and BDPs.  One ALMA project maps to one ADMIT object.</dd>
<dt><em>Memory Model</em></dt>
<dd>How the ADMIT object and state are kept up to date.
This is a combination of the Admit Object(s) and the Flow Manager state.
The memory model has a one-to-one mapping to what&#8217;s on disk.</dd>
<dt><em>Flow Manager</em></dt>
<dd>This is the infrastructure that strings Tasks together, manages the
connection map, decides if an AT and/or its BDPs are out of date and
the AT needs to be re-run, and manages task branches.</dd>
<dt><em>Project Manager</em></dt>
<dd>The PM is a container for one or more ADMIT objects, also referred to as a
multiflow.  The PM allows for data mining across different ALMA projects.</dd>
</dl>
</div>
<div class="section" id="user-interfaces">
<h3>User Interfaces<a class="headerlink" href="#user-interfaces" title="Permalink to this headline">¶</a></h3>
<dl class="docutils" id="uis">
<dt><em>casapy</em></dt>
<dd>For scripting or direct AT invocation, CASA will be
the supported environment.  ADMIT specific commands enabled
by <code class="code docutils literal"><span class="pre">import</span> <span class="pre">admit</span></code>. There is also the <code class="code docutils literal"><span class="pre">\#!/usr/bin/env</span> <span class="pre">casarun</span></code>
environment.</dd>
<dt><em>Graphical User Interface.</em></dt>
<dd>The GUI consists of two independent parts: 1) The BDP viewer which gives
a data summary and 2) the Workflow viewer which shows the connections
and state of ATs in the FlowManager, and allows simple modification of ATs in the
flow.  These are described in detail in sections
<a class="reference internal" href="#bdp-viewer-design"><span class="std std-ref">BDP Viewer Design</span></a> and <a class="reference internal" href="#workflow-viewer-design"><span class="std std-ref">Workflow Viewer Design</span></a>.</dd>
</dl>
</div>
</div>
<div class="section" id="base-classes">
<h2>Base Classes<a class="headerlink" href="#base-classes" title="Permalink to this headline">¶</a></h2>
<p>This section details the base classes for Tasks and Basic Data Products. A design
decision has been made that, once defined, attributes and key words in ATs and BDPs
cannot change type. This is enforced by the methods used to change the values of
these items.</p>
<div class="section" id="at-base-class">
<span id="at-base-design"></span><h3>AT Base Class<a class="headerlink" href="#at-base-class" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>The Admit Task (AT) base class defines all data members and methods that are common to
all ATs. Every AT in ADMIT must inherit directly or indirectly from the base class in
order to function properly.</p>
<p><em>Attributes</em></p>
<p>The following attributes are common to all ATs and cannot be overridden locally.
Additionally, most of these should never be directly accessed or changed by an
individual AT, they are handled by the methods in the base class only.</p>
<ul class="simple">
<li><strong>_keys</strong> - a dictionary which holds the keywords and values for each AT</li>
<li><strong>_stale</strong> - a boolean to denote whether the AT needs to be run (True) or not (False)</li>
<li><strong>_enabled</strong> - a boolean to denote whether the AT can be run (True) or should be
skipped (False)</li>
<li><strong>_do_plot</strong> - a boolean to denote whether the AT should plot any results to the
screen (True) or just to a hard copy (False)</li>
<li><strong>_plot_mode</strong> - an int to denote the plotting mode to use, values are:</li>
<li><strong>_type</strong> - a string to denote the type of AT that this is</li>
<li><strong>_bdp_out</strong> - a list to hold the output BDPs from this AT</li>
<li><strong>_bdp_out_map</strong> - a list to hold the uid&#8217;s of each output BDP</li>
<li><strong>_bdp_in</strong> - a list to hold the input BDPs for this AT</li>
<li><strong>_bdp_in_map</strong> - a list to hold the uid&#8217;s of each input BDP</li>
<li><strong>_valid_bdp_in</strong> - a list of tuples to indicate the expected input BDP types and
numbers. See the section on <a class="reference internal" href="examples.html#bdp-in"><span class="std std-ref">_valid_bdp_in</span></a> for details</li>
<li><strong>_valid_bdp_out</strong> - a list of tuples to indicate the expected output BSP types and
numbers. See the section on <a class="reference internal" href="examples.html#bdp-out"><span class="std std-ref">_valid_bdo_out</span></a> for details</li>
<li><strong>_alias</strong> - a string for a user defined alias for ease of use</li>
<li><strong>_taskid</strong> - an integer to hold a unique (within a given ADMIT project) id for each
AT</li>
<li><strong>_version</strong> - a string to hold the current version of the AT</li>
<li><strong>_needToSave</strong> - a boolean to denote whether or not the AT needs to be saved to disk</li>
<li><strong>_baseDir</strong> - the current working directory for the AT</li>
</ul>
<p><em>Methods</em></p>
<p>The following methods are supplied by the AT base class and should not be overloaded,
with the exception of the run() method, which <strong>must</strong> be overridden. Details of each
can be found in the <a class="reference internal" href="module/admit/AT.html#at-base-api"><span class="std std-ref">AT base class API</span></a>.</p>
<ul class="simple">
<li><strong>__len__</strong> - report the number of BDP outputs</li>
<li><strong>__getitem__</strong> - return the specified output BDP</li>
<li><strong>len2</strong> - returns the length of both the input and output BDP lists</li>
<li><strong>markUpToDate/markChanged</strong> - control the state of the _stale attribute</li>
<li><strong>isstale</strong> - return the state of the _stale attribute</li>
<li><strong>show</strong> - return the value of the _type attribute</li>
<li><strong>dir</strong> - returns the absolute directory name of the working directory</li>
<li><strong>mkdir</strong> - make a directory within the ADMIT hierarchy</li>
<li><strong>setkey</strong> - method used to change the value of any AT keyword or attribute, this
is the <strong>only</strong> supported method for changing keyword values</li>
<li><strong>getkey</strong> - method to get the current value of a keyword</li>
<li><strong>haskey</strong> - checks for the existence of a keyword</li>
<li><strong>checktype</strong> - check the type of a input against a BDP</li>
<li><strong>addoutput</strong> - add a BDP to the output list</li>
<li><strong>addinput</strong> - add a BDP to the input list</li>
<li><strong>addoutputbdp</strong> - add a BDP to a specific slot in the output list</li>
<li><strong>addinputbdp</strong> - add a BDP to a specific slot in the input list</li>
<li><strong>delinput</strong> - delete a specific BDP from the input list</li>
<li><strong>deloutput</strong> - delete a specific BDP from the output list</li>
<li><strong>clearinput</strong> - delete all BDPs from the input list</li>
<li><strong>clearoutput</strong> - delete all BDPs from the output list</li>
<li><strong>set_bdp_out</strong> - validate the _valid_output_bdp list and set internal parameters</li>
<li><strong>set_bdp_in</strong> - validate the _valid_input_bdp list and set internal parameters</li>
<li><strong>getVersion</strong> - return the version string</li>
<li><strong>getdtd</strong> - write out the dtd information to disk</li>
<li><strong>write</strong> - write out the AT to disk as XML</li>
<li><strong>save</strong> - write out any output BDPs to disk</li>
<li><strong>run</strong> - do anything that the AT is going to do, this is the <strong>only</strong> method that
can and also <strong>must</strong> be overloaded by child ATs</li>
<li><strong>execute</strong> - prepares the AT to be run</li>
<li><strong>checkfiles</strong> - check for the existence of expected output files</li>
<li><strong>delete</strong> - deletes the AT and any underlying BDPs</li>
<li><strong>copy</strong> - copies the given AT</li>
<li><strong>validateinput</strong> - check whether all input BDP slots are filled</li>
<li><strong>isequal</strong> - compare this AT to another</li>
<li><strong>summary</strong> - return the summary dictionary, <cite>_summary</cite></li>
</ul>
</div>
<div class="section" id="bdp-base-class">
<span id="bdp-base-design"></span><h3>BDP Base Class<a class="headerlink" href="#bdp-base-class" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>The BDP base class defines all data members and methods that are common to
all BDPs. Every BDP in ADMIT must inherit directly or indirectly from the base class in
order to function properly.</p>
<p><em>Attributes</em></p>
<p>The following attributes are common to all BDPs and cannot be overridden locally.</p>
<ul class="simple">
<li><strong>project/sous/gous/mous</strong> - strings for the project/source identifiers</li>
<li><strong>_date</strong> - string for the date of creation</li>
<li><strong>_type</strong> - string for the BDP type</li>
<li><strong>xmlFile</strong> - string for the file on disk the BDP will be written to</li>
<li><strong>_updated</strong> - boolean to denote whether the BDP has been updated since last save</li>
<li><strong>_uid</strong> - int for a unique identifier for the BDP</li>
<li><strong>_taskid</strong> - int for the taskid of the parent AT</li>
</ul>
<p><em>Methods</em></p>
<p>The following methods are supplied by the BDP base class and should not be overloaded.
Details of each can be found in the <a class="reference internal" href="module/admit.bdp/BDP.html#bdp-base-api"><span class="std std-ref">BDP base class API</span></a>.</p>
<ul class="simple">
<li><strong>getfiles</strong> - return a list of underlying files</li>
<li><strong>show</strong> - return the xml file name</li>
<li><strong>update</strong> - change the _updated node</li>
<li><strong>report</strong> - print to the screen the properties of the BDP</li>
<li><strong>setkey</strong> - set the value of an attribute</li>
<li><strong>haskey</strong> - check on the existence of an attribute</li>
<li><strong>get</strong> - return the value of the given keyword</li>
<li><strong>write</strong> - write the BDP to disk in XML format</li>
<li><strong>delete</strong> - delete the BDP and underlying files</li>
<li><strong>isequal</strong> - compare this BDP to another</li>
</ul>
</div>
<div class="section" id="table-base-class">
<span id="table-base-design"></span><h3>Table Base Class<a class="headerlink" href="#table-base-class" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>The Table class is a container for holding data in tabular format. The
table can hold data in column-row format and also in plane-column-row
format. Data can be added in instantiation, by columns, by rows, or by
entire planes.</p>
<p><em>Use Case</em></p>
<p>This class is used to store any tabular type data. It should not be used
directly but through the <a class="reference internal" href="#table-bdp-design"><span class="std std-ref">Table_BDP</span></a> class.</p>
<p><em>Attributes</em></p>
<ul class="simple">
<li><strong>columns</strong> - list for column labels</li>
<li><strong>units</strong> - list for units of each column</li>
<li><strong>planes</strong> - list for descriptor of planes in a 3D table</li>
<li><strong>data</strong> - a numpy array containing the tabular data</li>
<li><strong>description</strong> - string for a description or caption for the table</li>
</ul>
<p><em>Methods</em></p>
<p>For specifics of each method see <a class="reference internal" href="module/admit.util/Table.html#table-api"><span class="std std-ref">Table &#8212; Raw tabular data base.</span></a>.</p>
<ul class="simple">
<li><strong>addColumn</strong> - add a column to the table</li>
<li><strong>addRow</strong> - add a row to the table</li>
<li><strong>addPlane</strong> - add a plane to the table</li>
<li><strong>setData</strong> - set the data of the table</li>
<li><strong>getColumnByName</strong> - get a column of data by the header name</li>
<li><strong>getColumn</strong> - get a column of data by column index</li>
<li><strong>getHeader</strong> - get the header information</li>
<li><strong>getRow</strong> - get an individual row&#8217;s data</li>
<li><strong>getPlane</strong> - get a specific plane&#8217;s data</li>
<li><strong>isequal</strong> - compare this table to another</li>
</ul>
</div>
<div class="section" id="image-base-class">
<span id="image-base-design"></span><h3>Image Base Class<a class="headerlink" href="#image-base-class" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>The Image class is a container for holding images inside of a BDP. Each instance
can holds one image, but can hold multiple formates of that image (e.g. CASA, PNG).
Additionally, a thumbnail and auxiliary file can be included.</p>
<p><em>Use Case</em></p>
<p>This class is used to store images inside of ADMIT. It should not be used directly
but through the <a class="reference internal" href="#image-bdp-design"><span class="std std-ref">Image_BDP</span></a> class.</p>
<p><em>Attributes</em></p>
<ul class="simple">
<li><strong>images</strong> - dictionary of images and formats</li>
<li><strong>thumbnail</strong> - string of the thumbnail file name</li>
<li><strong>thumbnailtype</strong> - string for the thumbnail image format</li>
<li><strong>auxiliary</strong> - string for the auxiliary file name</li>
<li><strong>auxtype</strong> - string for the format of the auxiliary file</li>
<li><strong>description</strong> - string for a description/caption of the image</li>
</ul>
<p><em>Methods</em></p>
<p>For specifics of each method see <a class="reference internal" href="module/admit.util/Image.html#image-api"><span class="std std-ref">Image &#8212; Image data base.</span></a>.</p>
<ul class="simple">
<li><strong>write</strong> - write the image class out to disk as XML</li>
<li><strong>setkey</strong> - set the value of an attribute</li>
<li><strong>addimage</strong> - add an image to the dictionary, thumbnail, or auxiliary attributes</li>
<li><strong>addfile</strong> - add a file to the class</li>
<li><strong>getimage</strong> - get a specific image from the class by type</li>
<li><strong>removeimage</strong> - remove a specific image from the class</li>
<li><strong>delete</strong> - delete the class and the underlying files</li>
<li><strong>getthumbnail</strong> - get the thumbnail image</li>
<li><strong>getaux</strong> - get the auxiliary file</li>
<li><strong>isequal</strong> - compare this Image to another</li>
</ul>
<p><em>ImageDescriptor Class</em></p>
<p>This is a light weight class used for transporting an image and its information.</p>
</div>
<div class="section" id="line-base-class">
<span id="line-base-design"></span><h3>Line Base Class<a class="headerlink" href="#line-base-class" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>The Line class is a container for holding spectral line information inside of a BDP.</p>
<p><em>Use Case</em></p>
<p>The class is used to store spectral line information inside of ADMIT. It should not be
used directly but through the <a class="reference internal" href="#line-bdp-design"><span class="std std-ref">Line_BDP</span></a> class.</p>
<p><em>Attributes</em></p>
<ul class="simple">
<li><strong>name</strong> - string for the name of the molecule or atom</li>
<li><strong>transition</strong> - string for the transition/quantum number information</li>
<li><strong>energies</strong> - list of the upper and lower state energies</li>
<li><strong>energyunits</strong> - string for the units of the energies</li>
<li><strong>linestrength</strong> - float for the line strength of the transition</li>
<li><strong>lsunits</strong> - string for the units of the line strength</li>
<li><strong>frequency</strong> - float for the frequency of the transition</li>
<li><strong>funits</strong> - string for the units of the frequency</li>
</ul>
<p><em>Methods</em></p>
<p>For specifics of each method see <a class="reference internal" href="module/admit.util/Line.html#line-api"><span class="std std-ref">Line &#8212; Spectral line metadata.</span></a>.</p>
<ul class="simple">
<li><strong>setupperenergy</strong> - set the upper energy value</li>
<li><strong>setlowerenergy</strong> - set the lower energy value</li>
<li><strong>getupperenergy</strong> - get the upper energy value</li>
<li><strong>getlowerenergy</strong> - get the lower energy value</li>
<li><strong>setkey</strong> - change the value of an attribute</li>
<li><strong>write</strong> - write the class out to disk as XML</li>
<li><strong>isequal</strong> - compare this Line class with another</li>
</ul>
</div>
</div>
<div class="section" id="individual-at-designs">
<h2>Individual AT Designs<a class="headerlink" href="#individual-at-designs" title="Permalink to this headline">¶</a></h2>
<div class="section" id="file-at">
<span id="file-at-design"></span><h3>File_AT<a class="headerlink" href="#file-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>File_AT creates a File_BDP that contains a reference to an arbitrary file.
It has no real use (yet), except for bootstrapping a Flow AT series,
where it can be used to test the (large scale) system performance.
See also Ingest_AT for a real task that bootstraps a flow.</p>
<p><em>Use Case</em></p>
<p>Currently only used by Flow ATs for testing purposes, and thus useful
to bootstrap a flow, since it can start from an empty directory, and
create a zero length file.  This means you can create realistic flows,
in the same sense as full science flows, and measure the overhead
of ADMIT and the FlowManager.</p>
<p><em>Input BDPs</em></p>
<p>There are no input BDPs for this bootstrap AT. A filename is required to
create an output BDP, using an input keyword (see below).</p>
<p><em>Input Keywords</em></p>
<ul class="simple">
<li><strong>file</strong> -  The filename of the object. File does not have to exist yet.
There is no default.</li>
<li><strong>touch</strong> -   Update timestamp (or create zero length file
if file did not exist yet)? Default: False.</li>
</ul>
<p><em>Output BDPs</em></p>
<ul class="simple">
<li><strong>File_BDP</strong> - containing the string pointing to the file, following
the same convention the other file containers (Image_BDP,
Table_BDP) do, except their overhead.  There is no formal
requirement this should be a relative or absolute address.  A
symlink is allowed where the OS allows this, a zero length file is
also allowed.</li>
</ul>
<p><em>Procedure</em></p>
<p>Simple Unix tools, such as <strong>touch</strong>, are used. No file existence test done.
There are no CASA dependencies, and thus no CASA tasks used.</p>
<p><em>CASA tasks used</em></p>
<p>none</p>
</div>
<div class="section" id="flow-at">
<span id="flow-at-design"></span><h3>Flow_AT<a class="headerlink" href="#flow-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>There are a few simple FlowXY_AT&#8217;s implemented for experimenting with creating a flow,
without the need for CASA and optionally actual files.</p>
<p>This <em>Flow</em> series, together with File_AT, perform nothing more than
converting a dummy (one or more) input BDP(s) into (one or more) output BDP(s).
Optionally the file(s) associated with these BDP&#8217;s can be created as zero
length files. Currently three*Flow* ATs are implemented.
A simple Flow11_AT can be used for converting a single
File_BDP. Two variadic versions are available:
Flow1N_AT with 1 input and N outputs, and FlowN1_AT with N inputs
and 1 output.</p>
<ul class="simple">
<li><strong>Flow11_AT</strong> - one in, one out</li>
<li><strong>Flow1N_AT</strong> - one in, maNy out</li>
<li><strong>FlowN1_AT</strong> - maNy in, one out</li>
<li><strong>FlowMN_AT</strong> - Many in, maNy out</li>
</ul>
<p><em>Use Case</em></p>
<p>Useful to benchmark the basic ADMIT infrastructure cost of a (complex)
flow.</p>
<p><em>Input BDPs</em></p>
<ul class="simple">
<li><strong>File_BDP</strong> -  containing simply the string pointing to a file. This
file does not have to exist. FlowN1_AT can handle multiple input
BDPs.</li>
</ul>
<p><em>Input Keywords</em></p>
<p>Depending on which of the <em>FlowXY_AT</em> you have, the following keywords
are present:</p>
<ul class="simple">
<li><strong>file</strong> - The filename of the output object if there is only one
output BDP (Flow11_AT and FlowN1_AT). For Flow1N_AT the filename
is inherited by adding an index 1..N to the input filename, so this
keyword will be absent in this Flow1N_AT.</li>
<li><strong>n</strong> -  Normally variadic input or output can be determined otherwise
(e.g. it generally depends in a complex way on user parameters), but
for the Flow series it has to be manually set.  Only allowed for
Flow1N_AT where the <strong>file</strong> keyword is not use.  Default: 2.</li>
<li><strong>touch</strong> - Update timestamp (or create zero length file
if filename did not exist)? Default: False.</li>
<li><strong>exist</strong> - Check existence of the input BDP file(s). Default: True</li>
</ul>
<p><em>Output BDPs</em></p>
<ul class="simple">
<li><strong>File_BDP</strong> - containing simply the string pointing to the
file, following the same convention the other file containers
(Image_BDP, Table_BDP) do, except their overhead.
There is no formal requirement this should be a relative or absolute
address. A symlink is allowed where the OS allows this, a zero length
file is also allowed.</li>
</ul>
<p><em>Procedure</em></p>
<p>Only Unix tools, such as <strong>touch</strong>, are used.
There are no CASA dependencies, and thus no CASA tasks used.</p>
<p><em>CASA tasks used</em></p>
<p>None</p>
</div>
<div class="section" id="ingest-at">
<span id="ingest-at-design"></span><h3>Ingest_AT<a class="headerlink" href="#ingest-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>Ingest_AT converts a FITS file into a CASA Image.
It is possible to instead keep this a
symlink to the FITS file, as some CASA tasks are able to deal with
FITS files directly, potentially cutting down on the I/O overhead.
During the conversion to a CASA Image a few extra processing
steps are possible, e.g.
primary beam correction and taking a subcube instead of the
full cube. Some of these steps may add I/O overhead.</p>
<p><em>Use Case</em></p>
<p>Normally this is the first step that any ADMIT needs to do
to set up a flow for a project, and this is done by ingesting
a FITS file into a CASA Image. The SpwCube_BDP contains
merely the filename of this CASA Image.</p>
<p><em>Input BDPs</em></p>
<p>None. This is an exceptional case (for bootstrapping) where a (FITS) filename
is turned into a BDP.</p>
<p><em>Input Keywords</em></p>
<ul class="simple">
<li><strong>file</strong> -  The filename of the  FITS file. No default, this is the only required
keyword. Normally
with extension <strong>.fits</strong>, we will refer to this as <strong>basename.fits</strong>.
<em>We leave the issue of absolute/relative/symlinked names up to the caller.
We will allow this to be a casa image as well.</em></li>
<li><strong>pbcorr</strong> -  Apply a primary beam correction to the input FITS file? If true,
in CASA convention, a <strong>basename.flux.fits</strong> needs to be present. Normally,
single pointings from ALMA are not primary beam corrected, but mosaiced pointings
are and thus would need such a correction to make a noise flat image.
<em>We should probably allow a way to set another filename</em></li>
<li><strong>box</strong> - Instead of the more complex <strong>region</strong> selection described above, a
much simpler <em>blc,trc</em> type description is more effective.</li>
<li><strong>edge</strong> -  Edge channel rejections. Two numbers can be given, removing the first
and last selected number of channel. Default: 0,0</li>
<li><strong>mask</strong> -  If True a mask also needs to be created.
<em>need some discussion on the background of this curious option</em>
<em>importfits also has a somewhat related zeroblanks= keyword</em></li>
<li><strong>symlink</strong>  - True/False: if True, a symlink is kept to the fitsfile,
instead of conversion to a CASA Image.
This may be used in those rare cases where your whole flow can work
with the fits file, without need to convert to a CASA Image
Setting to True, also disables all other processing
(mask/region/pbcorr). This keyword should be used with caution,
because existing flows will then break if another task is added that
cannot use a FITS file.
[False]</li>
</ul>
<p><em>Output BDPs</em></p>
<ul class="simple">
<li><strong>SpwCube_BDP</strong> -  the spectral window cube.
The default filename for this CASA Image is <em>cim</em>.
There are no associated graphical cues for this BDP. Subsequent steps,
such as
<a class="reference internal" href="#cubespectrum-at-design"><span class="std std-ref">CubeSpectrum_AT</span></a> and
<a class="reference internal" href="#cubestats-at-design"><span class="std std-ref">CubeStats_AT</span></a>. In the case that the input
file was already a CASA image, and no subselection or PB correction
was done, this can be a symlink to the input filename.</li>
</ul>
<p><em>Procedure</em></p>
<p>Ignoring the symlink option (which has limited use in a full flow),
CASA&#8217;s importfits will first need to create a full copy of the FITS
file into a CASA Image, since there are no options to process a
subregion. In the case of multiple CASA programs processing (e.g. when
region selection plus primary beam correction), it may be useful to
check the performance difference between using tools and tasks.</p>
<p>Although using <strong>edge=</strong> can be a useful operation to cut down the
filesize a little bit, the catch-22 here is that - unless the user
knows - the bad channels are not known yet until CubeStats_AT has
been run, which is the next step after Ingest_AT. Potentially one can
re-run Ingest_AT.</p>
<p>CAVEAT: Using fits files, instead of CASA images, actually adds system
overhead each time an image has to be read. The saved time
from skipping <em>importfits</em> is quickly lost when your flow
contains a number of CASA tasks.</p>
<p><em>CASA tasks used</em></p>
<ul class="simple">
<li><strong>importfits</strong> - if just a conversion is done. No region selection
can be done here, only some masking operation to replace masked
values with 0s.</li>
<li><strong>imsubimage</strong> - only if region processing is done.  Note box= and
region= and chans= have common methods, our Ingest_AT should keep
that simpler.  For example, chans=&#8221;11~89&#8221; for a 100 channel cube
would be same as edge=11,10</li>
<li><strong>immath</strong> - if a primary beam correction is needed, to get noise
flat images.</li>
</ul>
<p>Alternatively, AT&#8217;s can also use the CASA tools. Especially this can be
a more efficient way to chain a number of small image operations, as
for example Ingest_AT would do if region selection and primary beam
correction are used.</p>
</div>
<div class="section" id="cubespectrum-at">
<span id="cubespectrum-at-design"></span><h3>CubeSpectrum_AT<a class="headerlink" href="#cubespectrum-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>CubeSpectrum_AT will compute one (or more) typical spectra from a spectral
line cube.  They are stored in a CubeSpectrum_BDP, which also contains a
graph of intensity versus frequency.  For certain types of cubes, these
can be effectively used in LineID_AT to identify spectral lines.</p>
<p>The selection of which point will be used for the spectrum is of
course subject to user input, but some automated options can be given.
For example, the brightest point in the cube can be used. The reference
pixel can be used. The size around this point can also be chosen, but this
is not a recommended procedure, as it can affect the LineID_AT procedure,
since it will smooth out (but increase S/N) the spectrum if large velocity
gradients are present. If more S/N is needed,
<a class="reference internal" href="#cubestats-at-design"><span class="std std-ref">CubeStats_AT</span></a> or
<a class="reference internal" href="#pvcorr-at-design"><span class="std std-ref">PVCorr_AT</span></a>
can be used.</p>
<p>Note in an earlier version, the SpectralMap_AT would allow multiple
points to be used. We deprecated this, in favor of allowing this AT to
create multiple points instead of just one. Having multiple spectra,
much like what is done in PVCorr_AT,  cross-correlations could be made
to increase the line detection success rate.</p>
<p>This AT used to be called PeakSpectrum in an earlier revision.</p>
<p><em>Use Case</em></p>
<p>This task is probably one of the first to run after ingestion, and will
quickly be able to produce a representative spectrum through the cube,
giving the user ideas how to process these data.  If spectra are taken
through multiple points, a diagram can be combined with a CubeSum
centered around a few spectra.</p>
<p><em>Input BDPs</em></p>
<ul class="simple">
<li><strong>SpwCube_BDP</strong> - The cube through from which the spectra are drawn. Required.
Special values <strong>xpeak,ypeak</strong> are taken from this cube.</li>
<li><strong>CubeSum_BDP</strong> - An optional BDP describing the image that represents the sum
of all emission. The peak(s) in this map can be selected for the spectra drawn.
This can also be a moment-0 map from a LineCube.</li>
<li><strong>FeatureList_BDP</strong> - An optional BDP describing features in an image or cube,
from which the RA,DEC positions can be used to draw the spectra.</li>
</ul>
<p><em>Input Keywords</em></p>
<ul class="simple">
<li><strong>points</strong> - One (or more) points where the spectrum is computed.
Special names are for special points:  <strong>xpeak,ypeak</strong> are for using
the position where the peak in the cube occurs.  <strong>xref,yref</strong> are the
reference position (CRPIX in FITS parlor).</li>
<li><strong>size</strong> - Size of region to sample over. Pixels/Arcsec.  Square/Round.
By default a single pixel is used. No CASA regions allowed here, keep
it simple for now.</li>
<li><strong>smooth</strong> - Some smoothing option applied to the spectrum. Use with
caution if you want to use this BDP for LineID.</li>
</ul>
<p><em>Output BDPs</em></p>
<ul class="simple">
<li><strong>CubeSpectrum_BDP</strong> - A table containing one or more spectra. For a single
spectrum the intensity vs. frequency is graphically saved. For multiple
spectra (the original intent of the deprecated SpectralMap_AT) it should
combine the representation of a CubeSum_BDP with those of the Spectra
around it, with lines drawn to the points where the spectra were taken.</li>
</ul>
<p><em>Procedure</em></p>
<p>After making a selection through which point the spectrum is taken,
grabbing the values is straightforward. For example, the imval task
in CASA will do this.</p>
<p><em>CASA tasks used</em></p>
<ul class="simple">
<li>imval - to extract a spectrum around a given position</li>
</ul>
</div>
<div class="section" id="cubestats-at">
<span id="cubestats-at-design"></span><h3>CubeStats_AT<a class="headerlink" href="#cubestats-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>CubeStats_AT will compute per-channel statistics, and can help
visualize what spectral lines there are in a cube.  They are stored in
a CubeStats_BDP.  For certain types of cubes, these can be effectively
used in LineID_AT to identify spectral lines. In addition, tasks such
as CubeSum_AT and LineCube_AT can use this if the noise depends on
the channel.</p>
<p><em>Use Case</em></p>
<p>Many programs needs to know (channel dependent) statistics from a cube in order to be able to
clip out the noise and get as much signal in the processing pipeline. In addition, the analysis
to compute channel based statistics needs to include some robustness, to remove signal. This
will become progressively hard if there is a lot of signal in the cube.</p>
<p><em>Input BDPs</em></p>
<ul class="simple">
<li><strong>SpwCube_BDP</strong> - input spectral window cube, for example as created with Ingest_AT.</li>
</ul>
<p><em>Input Keywords</em></p>
<ul class="simple">
<li><strong>robustness</strong> - Several options can be given here, to select the robust RMS.  (negative half gauss fit, robust, ...)</li>
</ul>
<p><em>Output BDPs</em></p>
<ul class="simple">
<li><strong>CubeStats_BDP</strong> - A table containing various quantities (min,max,median,rms) on a per channel basis.
A global statistics can (optionally?) also be recorded. The graphical output contains at least two plots:</li>
</ul>
<ol class="arabic simple">
<li>histogram of the distribution of Peak (P), Noise (N), and P/N, typically logarithmically;</li>
<li>A line diagram shows the P, N and P/N (again logarithmically) as function of frequency.
As a good diagnostic, the P/N should now not depend on frequency if only line-free channels
are compared. It can also be a good input BDP to LineID_AT.</li>
</ol>
<p><em>Procedure</em></p>
<p>The imstat task (or the ia.statistics tool) in CASA can compute plane
based statistics. Although the <em>medabsdevmed</em> output key is much better
than just looking at <span class="math">\(\sigma\)</span>, a signal clipping robust option may soon
be available to select a more robust way to compute what we call the
Noise column in our BDP. Line detection (if this BDP is used) is all
based on log(P/N).</p>
<p><em>CASA tasks used</em></p>
<ul class="simple">
<li>imstat - extract the statistics per channel, and per cube.  Note
that the tool and task have different capabilities, for us, we need
to the tool (ia.statistics)
Various new robustness algorithms are now
implemented using the new <em>algorithm=</em> keyword.</li>
</ul>
</div>
<div class="section" id="cubesum-at">
<span id="cubesum-at-design"></span><h3>CubeSum_AT<a class="headerlink" href="#cubesum-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>CubeSum_AT tries to create a representative <em>moment-0</em> map of a whole cube, by adding up all the emission, irrespective
of what lines there are. However, it will need to take into account that the RMS per channel can vary, so a single
global cutoff , as moment assumes, cannot be used. Hence this special version.</p>
<p><em>Use Case</em></p>
<p>A simple <em>moment-0</em> map early in a flow can be used to select a good location for selecting
a slice through the spectral window cube.  See PVSlice_AT.</p>
<p><em>Input BDPs</em></p>
<ul class="simple">
<li><strong>SpwCube</strong> - input cube</li>
<li><strong>CubeStats</strong> - Peak/RMS. Optional, but highly recommended of the RMS per channels varies.
Useful to be more liberal and allow cutoff to depend on the RMS, which may be channel dependent.</li>
</ul>
<p><em>Input keywords</em></p>
<ul class="simple">
<li><strong>cutoff</strong> - Above which emission (or below which, in case of absorption features).</li>
<li><strong>absorption</strong> - Identify absorption lines? True/False</li>
</ul>
<p><em>Output BDPs</em></p>
<ul class="simple">
<li><strong>CubeSum_BDP</strong> - An image</li>
</ul>
<p><em>Procedure</em></p>
<p>The method is a special case of Moment_AT, but we decided to keep it separate. Also
when the noise level across the band varies, the use of a CubeStats_BDP is essential.
Although it is optional here, it is highly recommended.</p>
<p><em>CASA Tasks Used</em></p>
</div>
<div class="section" id="featurelist-at">
<span id="featurelist-at-design"></span><h3>FeatureList_AT<a class="headerlink" href="#featurelist-at" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><em>Description</em></p>
<p>FeatureList_AT takes a LineCube, and describes the three-dimensional structure
of the emission (and/or absorption)</p>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Should we allow 2D maps as well?</p>
<p><em>Use Case</em></p>
<p><em>Input BDPs</em></p>
<p>Depending on which BDP(s) is/are given, and a choice of keywords, line
identification can take place.  For example, one can use both a
CubeSpectrum and CubeStats and use a conservative AND or a more
liberal OR where either both or any have detected a line.</p>
<blockquote class="last">
<div><ul class="simple">
<li><strong>CubeSpectrum</strong> - A spectrum through a selected point. For some cubes this is perfectly ok.</li>
<li><strong>CubeStats</strong>  - Peak/RMS. Since this table analyzed each plane of a cube, it will more likely pick up weaker lines, which a CubeSpectrum will miss.</li>
<li><strong>PVCorr</strong> - an cross-correlation table from a PVSlice_AT. This has the potential of detecting even weaker lines, but its creation via PVSlice_AT is a fine tunable process.</li>
</ul>
</div></blockquote>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="simple">
<li><strong>SpectralMap</strong>  - This BDP may actually be absorbed in CubeSpectrum, where there is more than one spectrum, where every spectrum is tied to a location and size over which the spectrum is computed.</li>
</ul>
<p><em>Input keywords</em></p>
<blockquote class="last">
<div><ul class="simple">
<li><strong>vlsr</strong> - If VLSR is not know, it can be specified here. Currently must be known, either via this keyword, or via ADMIT (header).</li>
</ul>
</div></blockquote>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Is that in admit.xml?   And what about VLSR vs. z?</p>
<blockquote>
<div><ul class="simple">
<li><strong>pmin</strong> -  Minimum likelihood needed for line detection. This is a number between 0 and 1.  [0.90]</li>
<li><strong>minchan</strong> - Minimum number of contiguous channels that need to contain a signal, to combine into a line. Note this means that each channel much exceed <strong>pmin</strong>.  [5]</li>
</ul>
</div></blockquote>
<p><em>Output BDPs</em></p>
<blockquote>
<div><ul class="simple">
<li><strong>LineList_BDP</strong> - A single LineList is produced, which is typically used by LineCube_AT to cut a large spectral window cube into smaller LineCubes.</li>
</ul>
</div></blockquote>
<p><em>Procedure</em></p>
<p>The line list database will be the splatalogue subset that is already
included with the CASA distribution.  This one can be used offline,
e.g. via the slsearch() call in CASA.  Currently astropy&#8217;s <code class="code docutils literal"><span class="pre">astroquery.splatalogue</span></code>
module has a <code class="code docutils literal"><span class="pre">query_lines()</span></code> function to query the full online web interface.</p>
<p>Once LineID_AT is enabled to attempt actual line identifications, one of those methods will
be selected, together with possible selections based on the astrophysical source. This will
likely need a few more keywords.</p>
<p>A few words about likelihoods.   Each procedure that creates a table is either supposed to deliver a probability, or LineID_AT must be able to compute it.   Let&#8217;s say for a computed RMS noise
<span class="math">\(\sigma\)</span>, a <span class="math">\(3\sigma\)</span> peak in a particular channel would have a likelihood
of 0.991 (or whatever value) for CubeStats.</p>
<p><em>CASA Tasks Used</em></p>
<p class="last">There are currently no tasks in CASA that can handle this.</p>
</div>
</div>
<div class="section" id="lineid-at">
<span id="lineid-at-design"></span><h3>LineID_AT<a class="headerlink" href="#lineid-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>LineID_AT creates a <a class="reference internal" href="#linelist-bdp-design"><span class="std std-ref">LineList_BDP</span></a>, a table of spectral lines discovered or detected
in a spectral window cube and images of spectra overlayed with potential identifications.
It does not need a spectral window cube for this, instead it
uses derived products (currently all tables) such a <a class="reference internal" href="#cubespectrum-bdp-design"><span class="std std-ref">CubeSpectrum_BDP</span></a>,
<a class="reference internal" href="#cubestats-bdp-design"><span class="std std-ref">CubeStats_BDP</span></a> or <a class="reference internal" href="#pvcorr-bdp-design"><span class="std std-ref">PVCorr_BDP</span></a>.</p>
<p><em>Use Case</em></p>
<p>In most cases the user will want to identify any spectral lines found in their data cube. This
task will determine what is/is not a line and attempt to identify it from a catalog.</p>
<p><em>Input BDPs</em></p>
<ul class="simple">
<li><a class="reference internal" href="#cubespectrum-bdp-design"><span class="std std-ref">CubeSpectrum_BDP</span></a> - just a spectrum through selected point(s).</li>
<li><a class="reference internal" href="#cubestats-bdp-design"><span class="std std-ref">CubeStats_BDP</span></a> Peak/RMS. Since this table analyses each plane of a cube, it will more likely pick up weaker lines, which a <a class="reference internal" href="#cubespectrum-bdp-design"><span class="std std-ref">CubeSpectrum_BDP</span></a> will miss.</li>
<li><a class="reference internal" href="#pvcorr-bdp-design"><span class="std std-ref">PVCorr_BDP</span></a> an cross-correlation table from a <a class="reference internal" href="#pvslice-at-design"><span class="std std-ref">PVSlice_AT</span></a>. This has the potential of detecting even weaker lines, but its creation via <a class="reference internal" href="#pvcorr-at-design"><span class="std std-ref">PVCorr_AT</span></a> is a fine tunable process.</li>
</ul>
<p><em>Input Keywords</em></p>
<ul>
<li><p class="first"><strong>vlsr</strong> : float
VLSR of the source (km/s). Default: -999999.99</p>
</li>
<li><p class="first"><strong>numsigma</strong> : float
Minimum intensity, in terms of the rms noise of the individual sepctra, to consider a
given channel to not be noise. In the case of CubeStats, where the units of the spectra
are sigma, this refers to the rms noise of the sigma spectra (noise of the noise).
Default: 5.0</p>
</li>
<li><p class="first"><strong>minchan</strong> : int
Minimum number of consecutive channels above numsigma to consider them
part of a line. Default: 4</p>
</li>
<li><p class="first"><strong>maxgap</strong> : int
The maximum gap to allow between clusters of channels to consider
them to be separate lines. Default: 3</p>
</li>
<li><p class="first"><strong>identifylines</strong> : boolean
If True then attempt to identify any detected spectral lines. If False, then just locate
regions of line emission and stop. False is useful if the rest frequency/vlsr are not
known.
Default: True</p>
</li>
<li><p class="first"><strong>allowexotics</strong> : bool
If True then do not limit the molecules that can be detected. If False, do not allow
transitions from molecules with &#8220;exotic&#8221; atoms to be included in lists. In
this case an exotic atom is one that is uncommon, but possible to be
detected in the right environment. The current list of &#8220;exotic&#8221; atoms is:
&#8220;Al&#8221;, &#8220;Cl&#8221;, &#8220;Mg&#8221;, &#8220;Mn&#8221;, &#8220;F&#8221;, &#8220;Li&#8221;, &#8220;Na&#8221;, &#8220;K&#8221;, and &#8220;Ti&#8221;.
Default: False</p>
</li>
<li><p class="first"><strong>recomblevel</strong> : string
What level of recombination line searching is requested. Three levels are available</p>
<blockquote>
<div><ul class="simple">
<li><cite>off</cite> : no recombination lines are allowed in the results</li>
<li><cite>shallow</cite> : only H and He, alpha and beta lines are allowed in the results</li>
<li><cite>deep</cite> : any recombination line is allowed in the results</li>
</ul>
</div></blockquote>
<p>Default: &#8220;shallow&#8221;</p>
</li>
<li><p class="first"><strong>segment</strong> : string
The name of the segment finder algorithm to use; choices are: ASAP and ADMIT.
(see <a class="reference internal" href="module/admit.util.segmentfinder/ASAPSegmentFinder.html#asapsegment"><span class="std std-ref">ASAPSegmentFinder &#8212; Finds segments of emission within a spectrum.</span></a> and <a class="reference internal" href="module/admit.util.segmentfinder/ADMITSegmentFinder.html#admitsegment"><span class="std std-ref">ADMITSegmentFinder &#8212; Finds segments of emission within a spectrum.</span></a> for details of each)
Default: &#8220;ADMIT&#8221;</p>
</li>
<li><p class="first"><strong>online</strong> : bool
If True then use the online splatalogue interface for searching for transitions. If
False the use the internal CASA slsearch. You must have an internet connection to use
the splatalogue interface.
Defualt: False</p>
</li>
<li><p class="first"><strong>smooth</strong> : list
Use this parameter to smooth the input spectrum.  Format is a list containing the name of the
smoothing algorithm followed by the parameters for
the algorithm, given in the order they are defined in the documentation.
The algorithms are: boxcar, gaussian, hanning, savgol, triangle, and welch.
All but savgol take a single integer parameter for the width. See <a class="reference internal" href="module/admit.util.filter/Filter1D.html#filter1d"><span class="std std-ref">Filter1D &#8212; 1-dimensional spectral filtering.</span></a> for
details on the individual algorithms and their keywords.
To do no smoothing, set the value to []. Example: [&#8220;boxcar&#8221;, 7] will do
a boxcar smooth with a width of 7.
Default: []</p>
</li>
<li><p class="first"><strong>recalcnoise</strong> : bool
A boolean to indicate whether the noise should be recalculated after smoothing. True
indicates that the noise should be recalculated, False indicates that the noise of the
unsmoothed spectrum should be used.
Default: False</p>
</li>
<li><p class="first"><strong>method</strong> : dictionary
A dictionary containing the peak finding algorithm(s) to use as the keys
(string) and dictionary containing the keyword/value arguments for the
algorithm as the value. Available methods are: PeakUtils and FindPeaksCWT
(see <a class="reference internal" href="module/admit.util.peakfinder/PeakUtils.html#peakutils"><span class="std std-ref">PeakUtils &#8212; A peak finding algorithm.</span></a> and <a class="reference internal" href="module/admit.util.peakfinder/FindPeaksCWT.html#findpeaks"><span class="std std-ref">FindPeaksCWT &#8212; Peak finding with continuous wavelet transforms.</span></a> for the specifics of each).
If more than one algorithm is given then each will be used in turn.
Default: {&#8220;PeakFinder&#8221; : {&#8220;thres&#8221;    : 0.0,
&#8220;min_sep&#8221;   : self.minchan,
&#8220;min_width&#8221; : self.minchan}</p>
</li>
<li><p class="first"><strong>pattern</strong> : str
String indicating if pattern detection is done. Patterns are defined as sets of peaks
which have the same separation which is caused by cloud rotation, expansion, etc. A
detailed explanation is given in the design documentation. Pattern detection works well
so long as there are not too many lines in the spectra. The code can determine whether
this criteria has been met. Available modes are:</p>
<ul class="simple">
<li>&#8216;ON&#8217;   Force pattern find to be on no matter what</li>
<li>&#8216;AUTO&#8217; Run pattern detection as long as there are not too many lines</li>
<li>&#8216;OFF&#8217;  No pattern detection</li>
</ul>
<p>Default: &#8220;AUTO&#8221;</p>
</li>
<li><p class="first"><strong>mode</strong> : string
If more than one peak finding algorithms is given in <strong>method</strong>, how should
the results be interpreted. Available modes are:</p>
<blockquote>
<div><ul>
<li><p class="first"><cite>ONE</cite> Consider a peak to be valid if it was found by any of the given methods</p>
</li>
<li><dl class="first docutils">
<dt><cite>TWO</cite> Consider a peak to be valid if it was found by at least two of the</dt>
<dd><p class="first last">methods. (if only 1 method is specified then this choice is ignored)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>ALL</cite> Consider a peak to be valid if it was detected by all given methods.</dt>
<dd><p class="first last">(if only 1 method is specified then this choice is ignored)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Default: &#8220;ONE&#8221;</p>
</li>
<li><p class="first"><strong>tier1width</strong> : float
The width over which to search for Tier 1 lines in km/s. Any lines
detected within this distance of a Tier 1 line will be identified
as that line. Defaults to 300.0 for sources with a VLSR of 150 km/s
and above, and 40.0 for sources with a VLSR below 150 km/s.</p>
</li>
<li><p class="first"><strong>csub</strong> : list
Which polynomial order to use for fitting the continuum for CubeStats
and CubeSpec based spectra. All CubeStats based spectra must be
continuum subtracted in order to obtain proper fits (peak, fwhm),
but continuum subtraction for CubeSpectrum based spectra is optional.
The first argument in the list is the order of polynomial to use for
the CubeStats based spectrum and the second is the order of fit to
use for CubeSpec based spectra.
Default: [1, None]  (1st order for CubeStat and no fitting for
Cubespec based spectra)</p>
</li>
<li><p class="first"><strong>references</strong> : str
The filename of a references list for optional overplotting in the
LineID plots. This is an ASCII file containing two columns:
one column of frequencies (a float), and one column of a reference
(line, a string). You can specify file references relative to
<cite>$ADMIT</cite>, e.g., references=&#8221;etc/ngc253_lines.list&#8221;
this is preferred to keep scripts portable, but an absolute filename
is perfectly legal.
Default: &#8220;&#8221;</p>
</li>
<li><p class="first"><strong>iterate</strong> : bool
If True then iterate for both the segment finder and the peak finder
to make them both sensitive to wide and strong narrow lines.
Default : True</p>
</li>
<li><p class="first"><strong>force</strong> : list of tuples or LineData objects
Force a given channel interval to be a specific line identification.
If force is given, LineID_AT will not try to find any lines in the
specified channel range, but rather take your input as correct.
Format:
[(frequency, UID, formula, name, transition, velocity, startchan, endchan)]
Examples:
[(115.2712, &#8216;CO&#8217;, &#8216;CO(1-0)&#8217;, &#8216;carbon monoxide&#8217;, &#8216;J=1-0&#8217;, 123.456, 23, 87)]</p>
<p>[(342.998, &#8216;Fred&#8217;, &#8216;Flintsone&#8217;, &#8216;unknown&#8217;, &#8216;unknown&#8217;, 0, 64, 128),
(238.012, &#8216;My Favorite Molecule&#8217;, &#8216;N/A&#8217;, &#8216;N/A&#8217;, &#8216;N/A&#8217;, 0, 4, 39)]</p>
<dl class="docutils">
<dt>[LineData(frequency=115.271, name=&#8217;Carbon Monoxide&#8217;, formula=&#8217;CO&#8217;,</dt>
<dd><p class="first last">uid=&#8217;CO_115.271&#8217;, transition=&#8216;1-0&#8217;, velocity=225.3,
chans=[25, 119])]</p>
</dd>
</dl>
<p>Note uid is what is the label used in the plots that LineID_AT creates.
LineData objects can be used instead of a tuple, as the contents of the tuple
is converted to a LineData object internally anyway.
Default: []</p>
</li>
<li><p class="first"><strong>reject</strong> : list of tuples
Reject a specific line identification.  Format: [(name, frequency)],
e.g., [(&#8220;carbon monoxide&#8221;, 115.2712), (&#8220;carbon monosulfide&#8221;, 97.981)].
Name is case insensitive. Frequency should be given to enough
precision that it uniquely identifies a line (a comparison is made at the
1 part in 10^6 for matching).
If frequency is None, all lines from the given molecule
will be rejected, i.e. [(&#8220;carbon monoxide&#8221;, None)] rejects all
CO transitions, including isotopomers: 12CO, 13CO, C18O etc.</p>
<p>Default: []</p>
</li>
</ul>
<p><em>Output BDP</em></p>
<p><a class="reference internal" href="#linelist-bdp-design"><span class="std std-ref">LineList_BDP</span></a> - A single LineList is produced, which is typically used
by <a class="reference internal" href="#linecube-at-design"><span class="std std-ref">LineCube_AT</span></a> to cut a large spectral window cube into smaller LineCube&#8217;s.</p>
<p><em>Output Graphics</em></p>
<p>A PNG or SVG of each input spectrum with any detected lines denoted and identified and channel
ranges for any detected lines. A summary plot of all spectra with identities and channel ranges
is also produced.</p>
<p><em>Procedure</em></p>
<p>LineID_AT is a task for identifying spectral lines from input spectra. All input spectra are
assumed to come from the same source. THe process is multistaged and is as follows:</p>
<ul class="simple">
<li>Read in spectra from one or more of <a class="reference internal" href="#cubespectrum-bdp-design"><span class="std std-ref">CubeSpectrum_BDP</span></a>, <a class="reference internal" href="#cubestats-bdp-design"><span class="std std-ref">CubeStats_BDP</span></a>,
and/or <a class="reference internal" href="#pvcorr-bdp-design"><span class="std std-ref">PVCorr_BDP</span></a>. The <a class="reference internal" href="#cubestats-bdp-design"><span class="std std-ref">CubeStats_BDP</span></a> is split into maximum and
minimum arrays, the former bieng more sensitive to emission features, the later more sensitive to
absorption features. The <a class="reference internal" href="#cubespectrum-bdp-design"><span class="std std-ref">CubeSpectrum_BDP</span></a>, can contain any number of spectra from
the same source. The <a class="reference internal" href="#pvcorr-bdp-design"><span class="std std-ref">PVCorr_BDP</span></a> contains only a single spectrum. Analysis of each
spectrum is done independently. Keywords used: <em>vlsr</em>, <em>smooth</em>, and <em>recalcnoise</em>.</li>
<li>Attempt continuum subtraction on each spectrum (except for <a class="reference internal" href="#pvcorr-bdp-design"><span class="std std-ref">PVCorr_BDP</span></a> based, by
definition these cannot have continuum). The presence of a continuum in the spectra can make it
difficult for LineID_AT to obtain a proper fit and thus properly identify any lines. Thus it is
strongly recommended to subtract a continuum from any spectra. Note that <a class="reference internal" href="#cubestats-bdp-design"><span class="std std-ref">CubeStats_BDP</span></a>
based spectra always have a &#8220;continuum&#8221; associated with them which needs to be removed. Keyword
used: <em>csub</em>, <em>segment</em>, <em>minchan</em>, <em>maxgap</em>, <em>numsigma</em>, and <em>iterate</em>.</li>
<li>Locate segments, regions of a spectrum where there appear to be lines, whether in emission or
absorption. Keywords used: <em>segment</em>, <em>minchan</em>, <em>maxgap</em>, <em>numsigma</em>, and <em>iterate</em>.</li>
<li>If <em>identifylines</em> is set to False, then processing ends here.</li>
<li>Search for any emission/absorption peaks with the specified method(s). Keywords used: <em>method</em>,
<em>numsigma</em>, <em>minchan</em>, and <em>numsigma</em>.</li>
<li>Search for any patterns in the detected peaks. Patterns arise from features like rotation or
expansion. Keywords used: <em>pattern</em>.</li>
<li>Attempt to identify each peak by first searching the Tier 1 list for any matches, then search
either slsearch or splatalogue for potential identifications. Keywords used: <em>online</em>,
<em>tier1width</em>, <em>allowexotics</em>, <em>recomblevel</em>, <em>force</em> and <em>reject</em>.</li>
<li>Merge the line lists from each spectrum into a final line list. Keywords used: None.</li>
</ul>
<p>See <a class="reference internal" href="#linedetection-design"><span class="std std-ref">Line Detection</span></a> for a full description of the line detection and identification
algorithms.</p>
<p><em>CASA Tasks Used</em></p>
<ul class="simple">
<li><strong>slsearch</strong> - for searching for potential line identifications.</li>
</ul>
</div>
<div class="section" id="linecube-at">
<span id="linecube-at-design"></span><h3>LineCube_AT<a class="headerlink" href="#linecube-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>A LineCube is a small spectral cube cut from the full spectral window cube, typically centered in
frequency/velocity on a given spectral line. LineCube_AT creates one (or more) of such cubes. It
is done after line identification (using a <a class="reference internal" href="#linelist-bdp-design"><span class="std std-ref">LineList_BDP</span></a>), so the appropriate
channel ranges are known.  Optionally this AT can be used without the line identification, and
just channel ranges are given (and thus the line will be designated as something like &#8220;U_115.27&#8221;.
The line cubes can be regridded and made to be the same size (in velocity space) by using the
equalize keyword. Additionally, using the width keyword the final width (in km/s) can be specified
for all output cubes. Typically the
continuum will have been subtracted these should only be the line emission, possibly with
contamination from other nearby lines. This is a big issue if there is a forest of lines,
and proper separation of such lines is a topic for the future and may be documented here as well
with a method.</p>
<p>One of the goals of LineCube_AT is to create identically sized cubes of
different molecular transitions for easy comparison and cross referenced analysis.</p>
<p><em>Use Case</em></p>
<p>A LineCube would be used to isolate a single molecular component in frequency dimensions. The produced subimage would be one of the natural inputs for the <a class="reference internal" href="#moment-at-design"><span class="std std-ref">Moment_AT</span></a> task.</p>
<p><em>Input BDPs</em></p>
<ul class="simple">
<li><a class="reference internal" href="#spwcube-bdp-design"><span class="std std-ref">SpwCube_BDP</span></a> - a (continuum subtracted) spectral window cube</li>
<li><a class="reference internal" href="#linelist-bdp-design"><span class="std std-ref">LineList_BDP</span></a> - a LineList, as created with <a class="reference internal" href="#lineid-at-design"><span class="std std-ref">LineID_AT</span></a>.
This LineList does not need to have identified lines. In the simple
version of LineID will just designate channel ranges as &#8220;U&#8221; lines.</li>
<li><a class="reference internal" href="#cubestats-bdp-design"><span class="std std-ref">CubeStats_BDP</span></a> - (optional) CubeStats associated with the
input spectral cube. This is useful if the RMS noise would depend on
the channel, which can happen for wider cubes, especially near the
spectral window edges. Otherwise the keyword <strong>cutoff</strong> will suffice.</li>
</ul>
<p><em>Input Keywords</em></p>
<ul class="simple">
<li><strong>grow</strong> : int
Extra channels added on either side of a line (as given by
the LineList).  If a negative number is given, its
positive value will be the number of channels of each
linecube.  This keyword has no meaning when gridding in
velocity space is done.
Default: 2 (add 2 channels to both sides of the line)</li>
<li><strong>width</strong> : float
Width of final cube in km/s, the line will be centered in the cube.
This will be the minimum width of the cube, as the final width
will be in whole channels.
The use of width and grow are mutually exclusive, width will take
precedence.
Default: 0.0 (no change in cube width)</li>
<li><strong>equalize</strong> : tuple
Whether or not to create equal size cubes (based on widest line
in input LineList_BDP), and width to regrid all channels to in km/s.
These cubes will be padded based on the values of grow or width.
Default: (False,0.0) Do not equalize and no regridding)</li>
</ul>
<p><em>Output BDP</em></p>
<p><a class="reference internal" href="#linecube-bdp-design"><span class="std std-ref">LineCube_BDP</span></a> - The output from this AT will be a line cube for each input spectral line. Each spectral cube will be centered on the spectral line and regridded to a common velocity scale, if requested.</p>
<p><em>Output Graphics</em></p>
<p>None</p>
<p><em>Procedure</em></p>
<p>For each line found in the input <a class="reference internal" href="#linelist-bdp-design"><span class="std std-ref">LineList_BDP</span></a> this AT will grab a subcube based on the input parameters.</p>
<p><em>CASA Tasks Used</em></p>
<ul class="simple">
<li><strong>imsubimage</strong> - to extract the final subcube from the main cube, including any masking</li>
<li><strong>imregrid</strong> - if regridding in velocity is needed</li>
<li><strong>imhead</strong> - to get proper input parameters for imsubimage</li>
</ul>
</div>
<div class="section" id="linesegment-at">
<span id="linesegment-at-design"></span><h3>LineSegment_AT<a class="headerlink" href="#linesegment-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>LineSegment_AT creates a list of channel ranges (segments) of potential line emission. These
segments are useful for ContinuumSub_AT in determining the line free channels.</p>
<p><em>Use Case</em></p>
<p>The output list will contain the channel ranges of line emission, thus the inverse will contain
channels of line-free (continuum) emission.</p>
</div>
<div class="section" id="pvslice-at">
<span id="pvslice-at-design"></span><h3>PVSlice_AT<a class="headerlink" href="#pvslice-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>PVSlice_AT creates a position-velocity slice through a spectral window
cube, which should be a representative 2 dimensional map showing the
spectral lines.</p>
<p><em>Use Case</em></p>
<p>A position-velocity slice is a great way to visualize all the emission
in a spectral window cube, next to CubeSum. Assuming one has choosen a
representative slice.</p>
<p><em>Input BDPs</em></p>
<ul class="simple">
<li><a class="reference internal" href="#spwcube-bdp-design"><span class="std std-ref">SpwCube_BDP</span></a> - Spectral Window Cube to take the slice through.  We normally
mean this to be a Position-Position-Velocity (or Frequency) cube.</li>
<li><strong>CubeSum_BDP</strong> - Optional. One of CubeSum or CubeStats can be used to
estimate the best slit. It will then use a moment of inertia analysis to decipher the best line
in RA-DEC for the slice.</li>
<li><strong>CubeStats_BDP</strong> - Optional. For each channel the position of the
maximum emission in that channel is used to derive (again via a
moments of inertia analysis) the center and direction of the slice.
If either a CubeSum_BDP or CubeStats_BDP is used, the slice is taken from
one edge of the map to the other end.</li>
</ul>
<p><em>Input Keywords</em></p>
<ul class="simple">
<li><strong>slice</strong> - A four element list with the beginning and ending coordinates.
The coordinates are 0-based pixel coordinates, though
HMS,DMS CASA style coordiantes should be allowed as well.</li>
<li><strong>slit</strong> - A four element list with the center, length and position angle
of the slit. 0 based coordinates and pixels coordinates are the default,
but CASA style coordinates (HMS,DMS and length) should be allowed as well.
Positions angles are measures east through north, in the usual astronomical
sense.</li>
<li><strong>major</strong> - Place the slit along the major axis?  Optionally the minor axis slit can
be taken. For rotation flow the major axis makes more  sense, for outflows
the minor axis makes more sense.  Default: True.</li>
<li><strong>width</strong> - Width of the slit, in pixels. This has to be an odd integer.
Default: 1</li>
<li><strong>gamma</strong> - The factor by which intensities are weighed (intensity**gamma) to compute
the moments of inertia from which the slit line is computed.
Default: 1</li>
<li><strong>clip</strong> - Clip value for the moment map (if used) or the CubeStats intensity (if used).</li>
</ul>
<p><em>Output BDP</em></p>
<ul class="simple">
<li><strong>PVSlice_BDP</strong> -</li>
</ul>
<p><em>Procedure</em></p>
<p>Either a specific line is given manually, or it can be derived from a reference map (or table).
By this it computes a (intensity weighted) moment of inertia, which then defines a major and minor
axis. Spatial sampling on output is the same as on input (this means if there ever
is a map with unequal sampling in RA and DEC, there is an issue, WSRT data?).</p>
<p><em>CASA Tasks Used</em></p>
<ul class="simple">
<li><strong>impv</strong> - to extract the PV slice</li>
</ul>
</div>
<div class="section" id="pvcorr-at">
<span id="pvcorr-at-design"></span><h3>PVCorr_AT<a class="headerlink" href="#pvcorr-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>PVCorr_AT uses a position-velocity slice to correlate distinct repeating
structures in this slice along the velocity (frequency) direction to find
emission or absorption lines.</p>
<p>Caveat: if the object of interest has very different types of emission regions,
e.g a nuclear and disk component which do not overlap, the detection may not work
as well.</p>
<p><em>Use Case</em></p>
<p>For weak lines (NGC253 has nice examples of this) none of the CubeStats or CubeSpectrum give
a reliable way to detect such lines, because they are essentially 1-dimensional cuts through the
cube and become essentially like noise.
When looking at a Position-Velocity slice, weak lines show up quite clearly to the eye,
because they are coherent 2D structures which mimic those of more obvious and stronger lines
in the same PVSlice. The idea is to cross-correlated an area around such strong lines along the
frequency axis and compute a cross-correlation coefficient.</p>
<p>There is also an interesting use case for virtual projects or multi-flows: imagine a PV slice with only
some weak lines (or worse, one weak line),
but in another related ADMIT object (i.e. a PVSlice from another spectrum window) it
is clearly detected. Formally a cross-correlation can only be done in velocity space when the
VLSR is known, but within a spectral window the non-linear effects are small. Borrowing a
template from another spw with widely different frequencies should thus be used with caution.</p>
<p><em>Input BDPs</em></p>
<ul class="simple">
<li><strong>PVSlice</strong> - The input PVSlice</li>
<li><strong>PVslice2</strong> - Alternative PVSlice (presumably from another virtual project)</li>
<li><strong>CubeStats</strong> -  Statistics on the parent cube</li>
</ul>
<p><em>Input Keywords</em></p>
<ul class="simple">
<li><strong>cutoff</strong> -  a conservative cutoff above which an area is defined for the N-th strongest line.
Can also be given in terms of sigma in the parent cube.</li>
<li><strong>order</strong> - Pick the N-th strongest line in this PV slice as the template.
Default: 1</li>
</ul>
<p><em>Output BDPs</em></p>
<ul class="simple">
<li><strong>PVCorr_BDP</strong> -  Table with cross-correlation coefficients</li>
</ul>
<p><em>Procedure</em></p>
<p>After a template line is identified (usually the strongest line in the
PVSlice), a conservative polygon (not too low a cutoff) is defined
around this, and cross correlated along the frequency axis. Currently
this needs to be a single polygon (really?)</p>
<p>Given the odd shape of the emission in a PVSlice, the correlation
coefficient is not exactly at the correct <em>velocity</em>.  A correction
factor needs to be determined based on identifying the template line
with a known line frequency, and VLSR. Since line identification is the
next step after this, this catch-22 situation needs to be resolved,
otherwise a small systemic offset can be present.</p>
<p><em>CASA tasks used</em></p>
<p>none exist yet that can do this. NEMO has a program written in C,
and the ideas in there will need to be ported to python, or use
SciPy&#8217;s cross-correlation routine.</p>
</div>
<div class="section" id="peakpointplot-at">
<span id="peakpointplot-at-design"></span><h3>PeakPointPlot_AT<a class="headerlink" href="#peakpointplot-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>PeakPointPlot takes a list of positions (x,y) and intensities (the maximum
through the cube at each given point in each slice) and plots each with a symbol size
related to the intensity value. The list is created by CubeStats as an option
(though will become default). The plot should be an interesting bubble diagram,
also good input for moment of inertia to get the initial condition for
a PVSlice.</p>
<p><em>Use Case</em></p>
<p><em>Input BDPs</em></p>
<ul class="simple">
<li><a class="reference internal" href="#spwcube-bdp-design"><span class="std std-ref">SpwCube_BDP</span></a> - the spectral cube</li>
</ul>
<p><em>Output BDPs</em></p>
<p><em>Input Keywords</em></p>
<p>Need a gamma-factor type keyword that controls how the plot size scales with the intensity.</p>
<p><em>Output Graphics</em></p>
<p>Graph</p>
</div>
<div class="section" id="moment-at">
<span id="moment-at-design"></span><h3>Moment_AT<a class="headerlink" href="#moment-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>Moment_AT creates a set of moment images from an input spectral window cube. The outputs from this
AT can help to analyze any spectral lines detected in a cube.</p>
<p><em>Use Case</em></p>
<p>Moment maps can be powerful tools for analyzing spectral lines. The maps produces by this task
give information on both spatial (x,y,z) and kinematic structure of the line emission. The output
can be fed into the Overlap Integral for further analysis.</p>
<p><em>Input BDPs</em></p>
<ul class="simple">
<li><a class="reference internal" href="#image-bdp-design"><span class="std std-ref">Image_BDP</span></a> - a spectral cube from which the moment is calculated, usually from a <a class="reference internal" href="#linecube-bdp-design"><span class="std std-ref">LineCube_BDP</span></a></li>
<li><a class="reference internal" href="#cubestats-bdp-design"><span class="std std-ref">CubeStats_BDP</span></a> - used to calculate the cutoffs, optional</li>
</ul>
<p><em>Input Keywords</em></p>
<ul class="simple">
<li><strong>moments</strong> - list of ints
The moments to be computed. An individual BDP is created for each
moment. See the immoments documentation for a description of the
moments that can be computed. Default: [0]</li>
<li><strong>numsigma</strong> : list of floats
The lower cutoff level for each moment in terms of sigma, an entry
for each moment can be given, or a single value can be given which
will be applied to all moments.
Default: [2.]</li>
<li><strong>sigma</strong> : float
The noise level to be used for calculating the cutoff values. Negative
values indicate that the AT should compute the value.
Inherited from the global RMS found in the CubeStats_BDP, if provided.
Default: -1.0</li>
<li><strong>chans</strong> : string
The channels to operate on, in normal CASA style.
Default: &#8220;&#8221; (all channels)</li>
<li><strong>mom0clip</strong> : float
The clip level in the mom0 map below which other moment maps will be masked,
but not to the mom0 map. This is in sigma units.
Default: 0.0 (not applied)</li>
</ul>
<p><em>Output BDPs</em></p>
<p><a class="reference internal" href="#moment-bdp-design"><span class="std std-ref">Moment_BDP</span></a> - A moment BDP is produced for each requested moment in the moments parameter.</p>
<p><em>Output Graphics</em></p>
<p>The task produces CASA images, PNGs, and histograms for each requested moment.</p>
<p><em>Procedure</em></p>
<p>If a CubeStats is supplied as input then the noise of the cube is obtained from it, otherwise
imstat is used to calculate the noise. This value is then combined with the requested numsigma
levels to specify the absolute cutoff values for the immoments task. If mom0clip is given then
the moment 0 map is used to calculate the
masking of the other moment maps. Once the moments are calculated the casaviewer is used (without the
gui interface) to generate PNGs of the moment maps. Histograms are also generated from each moment
map and stored in the output BDP.</p>
<p><em>CASA Tasks Used</em></p>
<ul class="simple">
<li><strong>immoments</strong> - to calculate the moments</li>
<li><strong>viewer</strong> - to produce PNGs of the CASA images</li>
<li><strong>imstat</strong> - to get the noise level of the cube and moment map(s)</li>
<li><strong>imval</strong> - to get the data for this histogram(s)</li>
</ul>
</div>
<div class="section" id="overlapintegral-at">
<span id="overlapintegral-at-design"></span><h3>OverlapIntegral_AT<a class="headerlink" href="#overlapintegral-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>OverlapIntegral_AT uses a series of indentically shaped images
(or cubes), and produces an equally shaped output image (or cube) that represents
how much spatial overlap exists between the input images. It can do this
optionally for a series of channels maps as well, so cubes are an allowed
input as well as 2D images.
In its simplest form this can be seen as a higher dimensional color.
For example, with 3 input cubes it could represent a Red, Green and Blue image.
Where emission occurs in all 3, and equally strong, the total emission
would be white. A number of mathematical transformations are offered to
produce this OverlapIntegral.</p>
<p><em>Use Case</em></p>
<p>Discovering the similarness (or dissimilarness) of transitions.
Similar discovery tools are PCA (Principle Component Analysis)</p>
<p><em>Input BDPs</em></p>
<ul class="simple">
<li><strong>Image</strong> - The input set of LineCube_BDP&#8217;s or Moment_BDP&#8217;s. They must all be
shaped the same way, and their WCS must agree. This places conditions on
how LineCube_AT has created the cubes.</li>
</ul>
<p><em>Input Keywords</em></p>
<ul class="simple">
<li><strong>chans</strong> - Selection of channels for overlap integral. Only used if the input
BDP&#8217;s are image cubes. This could also
contain a method if those channels are to be combined or reduced to a single
plane, like a moment-0, a red and blue wing for outflows, the different
components of a hyperfine transition etc.</li>
<li><strong>normalize</strong> - should each input image be normalized to its peak? Default is no.</li>
<li><strong>method</strong> - method how the overlap is to be computed.</li>
</ul>
<p><em>Output BDPs</em></p>
<ul class="simple">
<li><strong>OverlapIntegral_BDP</strong> -  An image. Do we need a special one, or is just
Image or Cube sufficient. It will have the same &#8220;shape&#8221; as the input set of
images.</li>
</ul>
<p><em>Procedure</em></p>
<p>Normally numpy arrays can be used (certainly for 2D images). For small set of
input cubes, numpy can also be used, but in order to remain scaleable,
no doubt casa::immath will need to be used.</p>
<p><em>CASA tasks used</em></p>
<ul class="simple">
<li><strong>immath</strong> - in case of large sets of image cubes, the numpy based math may exhaust memory, we will need a plan-B to use vanilla CASA.</li>
</ul>
</div>
<div class="section" id="smooth-at">
<span id="smooth-at-design"></span><h3>Smooth_AT<a class="headerlink" href="#smooth-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>Smooth_AT produces a smoothed version of an input image cube. The image may be
smoothed to a Gaussian beam with user-specified major and
minor axes and position angle. Alternatively, if the image cube has per-plane
beams defined, the user may choose to smooth to the beam that represents
the minimum-area ellipse that contains all the planes&#8217; restoring beams.
Smoothing in frequency/velocity space is also permitted.</p>
<p><em>Use Case</em></p>
<p>An image cube with varying resolutions per plane may complicate line detection
as well as users&#8217; interpretations of comparisons of emission morphology among
different spectral lines. In addition, low SNRlines may yield robust detections
if they are smoothed over a few channels before the cube is run through LineID.</p>
<p><em>Input BDPs</em></p>
<ul class="simple">
<li><strong>SpwCube</strong> - input cube</li>
</ul>
<p><em>Input keywords</em></p>
<ul class="simple">
<li><strong>bmaj</strong> - Dictionary containing user requested major axis of restoring beam for
smoothed image cube. Dictionary entries are &#8216;value&#8217; and &#8216;unit&#8217;. If value is negative,
use the minimum enclosing ellipse. Unit may be &#8216;arcsec&#8217; or &#8216;pix&#8217; for arcseconds or pixels,
respectively.</li>
<li><strong>bmin</strong> - Dictionary containing user requested minor axis of restoring beam for
smoothed image cube. Dictionary entries are &#8216;value&#8217; and &#8216;unit&#8217;. If value is negative,
use the minimum enclosing ellipse. Unit may be &#8216;arcsec&#8217; or &#8216;pix&#8217; for arcseconds or pixels,
respectively.</li>
<li><strong>bpa</strong>  - User requested position angle of restoring beam for smoothed image cube.
If negative, use minimum enclosing ellipse.</li>
<li><strong>velres</strong> - Dictionary containing user requested velocity resolution of smoothed image
cube. Dictionary entries are &#8216;value&#8217; and &#8216;unit&#8217;. If value is negative, no smoothing is done
in velocity. Unit may be &#8216;GHz&#8217;, &#8216;MHz&#8217;, &#8216;kHz&#8217;, &#8216;Hz&#8217; or &#8216;km/s&#8217;. If a velocity unit is chosen,
it is converted to a frequency using the cubes rest frequency keyword.</li>
</ul>
<p><em>Output BDPs</em></p>
<ul class="simple">
<li><strong>SpwCube</strong> - input cube</li>
</ul>
<p><em>Procedure</em></p>
<p>This method uses CASA&#8217;s toolkit (the convolve2d function) to convolve to a
target resolution that is set to be either user-specified or the minimum
enclosing beam of the set of per-plane beams. Before it performs the
convolution, it checks the convolving beam against the pixel scale of the
image. If the convolving beam is insufficiently resolved by the pixel scale,
then the code will smooth with the smallest circular beam that can be
represented well on the pixel grid. For velocity smoothing, it uses the
CASA toolkit function sepconvolve to separately convolve the cube along the
frequency axis with a Gaussian of the specified half width.</p>
<p><em>CASA Tasks Used</em></p>
<ul class="simple">
<li><strong>imhead</strong> - retrieves the pixel scale of the image for use in checking how
well the convolving beam can be represented on the image.</li>
</ul>
</div>
<div class="section" id="regrid-at">
<span id="regrid-at-design"></span><h3>Regrid_AT<a class="headerlink" href="#regrid-at" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>Regrid_AT regrids N input image cubes onto a common spatial and/or spectral grid.</p>
<p><em>Use Case</em></p>
<p>A user may desire to compute line ratios with a set of image cubes. In the
general case, these image cubes will have neither the same coordinate system,
spectral setup, not resolution. Regrid_AT may be used in conjunction with Smooth_AT
to produce sets of output image cubes that have common resolutions and coordinate
systems that facilitate analysis.</p>
<p><em>Input BDPs</em></p>
<ul class="simple">
<li><strong>SpwCube</strong> - input cubes</li>
</ul>
<p><em>Input keywords</em></p>
<dl class="docutils">
<dt><strong>do_spatial_regrid</strong>: Whether or not to do spatial regridding. The default (True)</dt>
<dd>enables spatial regridding. If set to True (or left default), the pix_scale keyword
will be used to determine the appropriate pixel size to regrid the images to.</dd>
<dt><strong>pix_scale</strong></dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">The pixel size on which to regrid all the images. If set to a value &lt; 0</span><dd>(or left default), then Regrid_AT uses the minimum pixel scale for all images. Unit is arcsec.</dd>
<dt><strong>do_freq_regrid</strong>: Whether or not to do frequency regridding. The default (False)</dt>
<dd>disables spectral regridding. If set to True, the chan_width keyword will be used
to determine the appropriate channel width to regrid the images to.</dd>
<dt><strong>chan_width</strong></dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">double</span><dd>The channel width with which to regrid the images. If negative, then
the default is the minimum such channel width. Unit is Hz.</dd>
</dl>
<p><em>Output BDPs</em></p>
<ul class="simple">
<li><strong>SpwCube</strong> - input cubes</li>
</ul>
<p><em>Procedure</em></p>
<p>This method uses the CASA task imregrid to a spectrally/spatially regrid a
set of image cubes to either user-specified pixel sizes / channel widths
or, by default, the minimum pixel size / channel width of the set of cubes.
The user may specify whether to do spatial and/or spectral regridding. If spatial
regridding is desired, the user may specify the desired (common) output pixel size
for each image. The resultant image cubes are then regridded via interpolation
such that area of sky covered by each output image is bounded by the min/max of
the right ascension / declinations covered by each input cube. If, for a given
output cube, pixels lie outside the region covered by the input cube, they are
blanked. If the user does not specify a desired pixel scale to regrid to, the
default behavior is to regrid to the minimum pixel size in the set of input images.
If spectral regridding is desired, Regrid_AT computes the minimum and maximum
frequencies covered by the input data cubes and either regrids to a channel width
(in Hz) that is user specifed or the minimum of the input cubes&#8217; channel widths.
As with spatial regridding, this is done via interpolation.
NB: because regridding is done via interpolation, the user must exercise care.
For spatial regridding, images MUST have pixel units of flux per unit solid angle,
NOT per pixel. Otherwise, Regrid_AT will not conserve flux. For spectral regridding,
a correction factor has been included to account for this, so spectral regridding
should conserve flux.</p>
<p><em>CASA Tasks Used</em></p>
<ul class="simple">
<li><strong>imhead</strong> - retrieves header information to compute the input coordinate system and
spectral setup.</li>
<li><strong>imregrid</strong> - performed the interpolation of the input images to the desired coordinate
system and spectral setup.</li>
</ul>
</div>
</div>
<div class="section" id="individual-bdp-designs">
<span id="bdp-designs"></span><h2>Individual BDP Designs<a class="headerlink" href="#individual-bdp-designs" title="Permalink to this headline">¶</a></h2>
<div class="section" id="table-bdp">
<span id="table-bdp-design"></span><h3>Table_BDP<a class="headerlink" href="#table-bdp" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>A BDP wrapper for the <a class="reference internal" href="#table-base-design"><span class="std std-ref">Table Base Class</span></a>. Any BDP that includes a Table should inherit from
this class.</p>
<p><em>Inherits From</em></p>
<p><a class="reference internal" href="#bdp-base-design"><span class="std std-ref">BDP Base Class</span></a></p>
<p><em>Constituents</em></p>
<p>An instance of the Table class</p>
</div>
<div class="section" id="image-bdp">
<span id="image-bdp-design"></span><h3>Image_BDP<a class="headerlink" href="#image-bdp" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>A BDP wrapper for the <a class="reference internal" href="#image-base-design"><span class="std std-ref">Image Base Class</span></a>. Any BDP that includes an Image should inherit from
this class.</p>
<p><em>Inherits From</em></p>
<p><a class="reference internal" href="#bdp-base-design"><span class="std std-ref">BDP Base Class</span></a></p>
<p><em>Constituents</em></p>
<p>An instance of the Image class.</p>
</div>
<div class="section" id="line-bdp">
<span id="line-bdp-design"></span><h3>Line_BDP<a class="headerlink" href="#line-bdp" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>A BDP wrapper for the <a class="reference internal" href="#line-base-design"><span class="std std-ref">Line Base Class</span></a>. Any BDP that includes line information should
inherit from this class.</p>
<p><em>Inherits From</em></p>
<p><a class="reference internal" href="#bdp-base-design"><span class="std std-ref">BDP Base Class</span></a></p>
<p><em>Constituents</em></p>
<p>An instance of the Line class.</p>
</div>
<div class="section" id="linelist-bdp">
<span id="linelist-bdp-design"></span><h3>LineList_BDP<a class="headerlink" href="#linelist-bdp" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>A table of spectral lines detected in a spectrum, map, or cube. Output from the <a class="reference internal" href="#lineid-at-design"><span class="std std-ref">LineID_AT</span></a>.</p>
<p><em>Inherits From</em></p>
<p><a class="reference internal" href="#table-bdp-design"><span class="std std-ref">Table_BDP</span></a></p>
<p><a class="reference internal" href="#image-bdp-design"><span class="std std-ref">Image_BDP</span></a></p>
<p><em>Constituents</em></p>
<p>The items of this BDP will be a table with the following columns:</p>
<ul class="simple">
<li><strong>frequency</strong> - in GHz, precise to 5 significant figures</li>
<li><strong>uid</strong> - ANAME-FFF.FFF ; e.g.  CO-115.271,   N2HP-93.173,   U-98.76</li>
<li><strong>formula</strong> - CO, CO_v1, C2H, H13CO+</li>
<li><strong>fullname</strong> - Carbon monoxide, formaldehyde</li>
<li><strong>transition</strong> - Quantum numbers</li>
<li><strong>velocity</strong> - vlsr or offset velocity (based on rest frequency)</li>
<li><strong>energies</strong> - lower and upper state energies in K</li>
<li><strong>linestrength</strong> - spectral line strength in D$^2$</li>
<li><strong>peakintensity</strong> - the peak intensity of the line in Jy/bm</li>
<li><strong>peakoffset</strong> - the offset of the peak from the rest frequency in MHz</li>
<li><strong>fwhm</strong> - the FWHM of the line in km/s</li>
<li><strong>channels</strong> - the channels the line spans (typically FWHM)</li>
<li><strong>peakrms</strong> - the rms of the peak in sigma units</li>
<li><strong>blend</strong> - denotes which lines are blended together (by common number), 0 indicates no blend</li>
<li><strong>force</strong> - denotes whether or not the line was forced by the user</li>
</ul>
<p>Additionally an item to denote whether the velocity is vlsr or offset velocity.
The offset velocity will only be used when the vlsr is not known and cannot be determined.
The coordinates of where the line list applies along with units will also be stored. There is an
additional table which contains the spectra that were used in the LineID_AT, these are used to
reproduce the plots and in the LineID user interface.</p>
</div>
<div class="section" id="linecube-bdp">
<span id="linecube-bdp-design"></span><h3>LineCube_BDP<a class="headerlink" href="#linecube-bdp" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>A Line Cube is a subcube of the initial image, This subcube represents the emission of a
single (or degenerate set) spectral line, both in spatial and velocity/frequency dimensions.
It is the output from the <a class="reference internal" href="#linecube-at-design"><span class="std std-ref">LineCube_AT</span></a>.</p>
<p><em>Inherits From</em></p>
<p><a class="reference internal" href="#spwcube-bdp-design"><span class="std std-ref">SpwCube_BDP</span></a></p>
<p><em>Constituents</em></p>
<p>An image of the output cube, a SPW cube, a listing of the molecule, transition, energies, rest freq, line width, and channels that the line covers.</p>
</div>
<div class="section" id="moment-bdp">
<span id="moment-bdp-design"></span><h3>Moment_BDP<a class="headerlink" href="#moment-bdp" title="Permalink to this headline">¶</a></h3>
<p><em>Description</em></p>
<p>The moment BDP is designed to hold the products of a run of immoments.</p>
<p><em>Inherits From</em></p>
<p><a class="reference internal" href="#image-bdp-design"><span class="std std-ref">Image_BDP</span></a></p>
<p><a class="reference internal" href="#line-bdp-design"><span class="std std-ref">Line_BDP</span></a></p>
<p><em>Constituents</em></p>
<p>The BDP will contain an image (in both CASA and PNG formats), a thumbnail of the image, a histogram
of the image, and any spectral line information associated with the images. It also contains the
specific moment (as an int) that this instance holds.</p>
</div>
<div class="section" id="spwcube-bdp">
<span id="spwcube-bdp-design"></span><h3>SpwCube_BDP<a class="headerlink" href="#spwcube-bdp" title="Permalink to this headline">¶</a></h3>
<p>A Spectral Window Cube is a generic designation for a 3D (or 4D if more than one polarization is present)
Position-Position-Frequency cube. They describe a single spectral window where the axis can be describe
as being contiguous in frequency.</p>
<p><em>Inherits From</em></p>
<p><a class="reference internal" href="#image-bdp-design"><span class="std std-ref">Image_BDP</span></a></p>
</div>
<div class="section" id="cubespectrum-bdp">
<span id="cubespectrum-bdp-design"></span><h3>CubeSpectrum_BDP<a class="headerlink" href="#cubespectrum-bdp" title="Permalink to this headline">¶</a></h3>
<p>CubeSpectrum will contain a table of a spectrum through the whole cube, at a
single point (with optional averaging over a region or channels).</p>
<p>This differs from the CubeStats where in theory one can also plot &#8220;a
spectrum&#8221; where the brightest value &#8220;anywhere&#8221; in each channel is plotted
vs. frequency.</p>
<p>This was previously called PeakSpectrum.  This version has a keyword
describing where this point was taken.</p>
<p>NOTE: In principal, CubeSpectrum is redundant with SpectralMap. A CubeSpectrum
is just a SpectralMap where N=1.  So we should consider deprecating CubeSpectrum.</p>
<p><em>Inherits From</em></p>
<p><a class="reference internal" href="#table-bdp-design"><span class="std std-ref">Table_BDP</span></a></p>
</div>
<div class="section" id="cubestats-bdp">
<span id="cubestats-bdp-design"></span><h3>CubeStats_BDP<a class="headerlink" href="#cubestats-bdp" title="Permalink to this headline">¶</a></h3>
<p>Produces per channel statistics on an input image cube. Output
format is a table with data described below.  In addition to
per channel output, (optional?) per cube values are also be
computed.</p>
<p><em>Constituents</em></p>
<blockquote>
<div><p><strong>mean</strong>    Mean value of the whole cube</p>
<p><strong>sigma</strong>   Sigma</p>
<p><strong>maxval</strong>  Maximum value in the cube</p>
<p><strong>maxpos</strong>  Integer list of two elements where the maximum value in the cube was found</p>
</div></blockquote>
<p><em>Inherits From</em></p>
<p><a class="reference internal" href="#table-bdp-design"><span class="std std-ref">Table_BDP</span></a></p>
<p>Table columns are: <strong>channel</strong>, <strong>frequency</strong>, <strong>mean</strong>, <strong>sigma</strong>, and <strong>peakval</strong>.
Here the mean and sigma are determined robustly by trying to reject signal as much
as possible. Several algorithms to do this robustly are available in the statistics
computation engines.</p>
</div>
<div class="section" id="pvcorr-bdp">
<span id="pvcorr-bdp-design"></span><h3>PVCorr_BDP<a class="headerlink" href="#pvcorr-bdp" title="Permalink to this headline">¶</a></h3>
<p>Position-Velocity diagram based correlation table (vs. frequency) which can be used
as one of the inputs to a LineID_AT program.</p>
</div>
</div>
<div class="section" id="logging-infrastructure">
<span id="id1"></span><h2>Logging Infrastructure<a class="headerlink" href="#logging-infrastructure" title="Permalink to this headline">¶</a></h2>
<p>ADMIT has its own logging infrastructure that relies on the Python builtin <strong>logging</strong> module. The
main logging module is instantiated and set up automatically in the Admit base class.
All logging activity is written to both the screen and to admit.log in the Admit &#8220;baseDir&#8221;.
Each logging message is given an integer level from 1 to 100. Several levels have been given
easy to remember names:</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Level</th>
<th class="head">Numeric Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CRITICAL</td>
<td>50</td>
</tr>
<tr class="row-odd"><td>ERROR</td>
<td>40</td>
</tr>
<tr class="row-even"><td>WARNING</td>
<td>30</td>
</tr>
<tr class="row-odd"><td>INFO</td>
<td>20</td>
</tr>
<tr class="row-even"><td>DEBUG</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>and are used as logging.WARNING, logging.INFO, etc.</p>
<p>The Admit logger is setup with a default level of INFO, meaning that and message marked INFO (20) and higher
will be written to the log and screen, while any message marked at a lower level will be dropped. The logging
level can be changed by calling</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Admit</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">setlogginglevel</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>             <span class="c1"># numeric method</span>
<span class="n">a</span><span class="o">.</span><span class="n">setlogginglevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>   <span class="c1"># text based</span>
</pre></div>
</div>
<p>The logging infrastructure is designed in such a way that it only needs to be
instantiated once and then all subsequent modules share it. Thus in any AT, just add
import logging to the imports list and all log messages will be properly handled.
To log a message just use the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Your log message&quot;</span><span class="p">)</span>      <span class="c1"># log an info level message</span>
<span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;A warning message&quot;</span><span class="p">)</span>  <span class="c1"># log a warning message</span>
<span class="n">logging</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="s2">&quot;Another message&quot;</span><span class="p">)</span>     <span class="c1"># log to a specific log level</span>
</pre></div>
</div>
<p>The logging level can be set differently for each AT, allowing the user/coder the ability
to log all messages from a single AT while supressing any and all others. This is
accomplished by:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">ll</span> <span class="o">=</span> <span class="n">LineID_AT</span><span class="p">()</span>
<span class="n">ll</span><span class="o">.</span><span class="n">setlogginglevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>  <span class="c1"># sets the logging level to debug</span>
                                   <span class="c1"># for this specific instance of LineID_AT</span>
</pre></div>
</div>
<p>The logging level will return to the global default after the AT runs.</p>
<p>In addition to the default logging calls provided by the Python logging module, the ADMIT
logger offers two customized calls that will send formatted messages to the log(s) that act
as headers and subheaders. The intention of these methods is to allow the code to put statements
in the logs that are easy to notice. One example of using the heading call is when each AT is run
it sends a message to the logs that it is beginning. As an example when the Ingest_AT runs the
following will appear in the log(s) and on the screen:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">INFO</span> <span class="p">:</span>
<span class="n">INFO</span> <span class="p">:</span>
<span class="n">INFO</span> <span class="p">:</span>    <span class="n">Executing</span> <span class="n">Ingest_AT</span> <span class="n">V0</span><span class="o">.</span><span class="mf">7.7</span>
<span class="n">INFO</span> <span class="p">:</span>
<span class="n">INFO</span> <span class="p">:</span>
</pre></div>
</div>
<p>Having the blank lines makes it easy to visually delineate sections inside of the log.</p>
</div>
<div class="section" id="graphical-user-interface-design">
<span id="gui-design"></span><h2>Graphical User Interface Design<a class="headerlink" href="#graphical-user-interface-design" title="Permalink to this headline">¶</a></h2>
<div class="section" id="bdp-viewer-design">
<span id="id2"></span><h3>BDP Viewer Design<a class="headerlink" href="#bdp-viewer-design" title="Permalink to this headline">¶</a></h3>
<p>The purpose of the BDP viewer is to give the user an always up-to-date
summary of the data that have been produced by ADMIT for the target
ingested file(s).  In this model, each view window is associated with
one ADMIT object.  As the user produces data by creating and executing
ATs through a flow, the view representing the data will be refreshed.
Tasks which create images or plots will also create thumbnails which can be
shown in the view and clicked on to be expanded or to get more information.
We adopt a web browser as the basic view platform because</p>
<blockquote>
<div><ol class="lowerroman simple">
<li>Much of the interaction, format (e.g., tabbed views), and bookkeeping required is already provided by a web browser platform, decreasing greatly the amount of code we have to write.</li>
<li>Users are quite familiar with browsers, making learning the BDP viewer easier. Furthermore, they can user their browser of choice.</li>
<li>By doing so, we can adopt the look and feel of the ALMA pipeline web log, keeping to a style with which ALMA users will be familiar.</li>
<li>Python provides an easy-to-use built-in HTTP server (BaseHTTPServer), so no external Python package is needed.</li>
<li>Writing the data summary in HTML allows us flexibility to test various view styles and quickly modify the style as our needs change.</li>
</ol>
</div></blockquote>
<p>When an ADMIT object is instantiated, it will start a BDP view server on
a unique localhost port in a separate thread and report to the user the
localhost web address on which to view the BDPs for that ADMIT object.
The server will be given the data output directory as its document root.
Upon execution, each AT will invoked a method on the ADMIT object that
updates an HTML file(s) in the document root with the newly available items.
Users can monitor different ADMIT objects in different browser tabs.</p>
<p>Javascript and cascading style sheet (CSS) resources will be installed in
$ADMIT/resources as part of make.   These will principally be external
packages which we unpack without modification, while preserving the
option to do so in the future.</p>
<p>The resources will include the well-known Javascript code <a class="reference external" href="http://livejs.com">Live.js</a> which auto-refreshes pages when something has
changed.  This script polls once per second for changes in local HTML,
CSS, or Javascript.  If we find resource usage is an issue, we could
increase the poll interval. We can also modify the script to monitor
other file types, but it is simpler to use a timestamp in a comment tag
in index.html that gets modified at at each update.</p>
<p>Following the ALMA Archive Pipeline web pages, we will use the <a class="reference external" href="http://getbootstrap.com">Bootstrap
Framework</a> and <a class="reference external" href="http://www.fancyapps.com/fancybox">fancybox</a> for the layout style.   The general
layout will be grid-like.  Each AT writes its summary information in its
own division (&#8220;div&#8221; in CSS language) in the web page, and divisions are
added at the bottom as they are created.  So the order of divisions on
the web page are essentially workflow order (for simple flows).  In each
division, the BDP info will be laid out horizontally as thumbnails or
links to secondary pages. For multiflows, we may want a customization in
which all ADMIT objects in the multiflow are represented on the page with
clear graphical separation.</p>
<div class="section" id="implementation-details">
<h4>Implementation Details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h4>
<p>Upon instantiation of an ADMIT project, a boolean parameter <em>dataserver</em>
controls whether the data server is started or not via the method
<em>startDataViewer()</em>.   For ALMA Archive Pipeline use, we want this boolean
value to be False, but for normal users it should be True.  The data
server is an http server started on a local open port determined by the O/S,
using <a class="reference external" href="module/admit.util/AdmitHTTP.html#admit.util.AdmitHTTP.AdmitHTTPServer">AdmitHTTPServer</a>
and Python&#8217;s <em>threading.Thread</em> class.
The document root
is the directory returned by <em>Admit.dir()</em>. The Admit class
method <em>updateHTML</em> creates and update index.html as a representation
of the current state of the Admit.  This method is closely related to
<em>Admit.summary()</em> since the contents of index.html will be derived from
the Admit.summaryData, and the expectation is that summary() is called
beforehand.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/databrowser.png"><img alt="Data browser web page with Line ID section open." src="_images/databrowser.png" style="width: 881.6px; height: 675.2px;" /></a>
</div>
</div>
</div>
<div class="section" id="workflow-viewer-design">
<span id="id3"></span><h3>Workflow Viewer Design<a class="headerlink" href="#workflow-viewer-design" title="Permalink to this headline">¶</a></h3>
<p>The Workflow Viewer, a stand-alone user interface of ADMIT, will provide a way
of creating and viewing the task flows used in ADMIT pipeline computation.
It acts as the front end of the Flow Manager object to let users modify the
attributes and keywords of ATs, see the state of ATs, and add or remove ATs
from the flow. Once a flow is created or modified, it can be executed by
pressing a button on the viewer. A Python script can also be generated based
on the flow.</p>
<p>There will be two separated windows for the viewer. One is the two-pane window
for users to create or modify the flow; the other is the optional display-only
window that shows the flow diagram generated by <em>dot</em> (the graphing tool of
GraphViz), if it is available in the user&#8217;s operating system.</p>
<p>Tkinter, the Python&#8217;s standard Graphical User Interface package, will be used
to implement the Workflow Viewer user interface, so no additional GUI software
packages need to be installed.</p>
<p>The graphics and layout of the screens shown here are merely to illustrate
the underlying functionality. The actual look and feel will be developed over
time with the actual implementation.</p>
<div class="section" id="use-cases">
<h4>Use Cases<a class="headerlink" href="#use-cases" title="Permalink to this headline">¶</a></h4>
<p><em>Use Case 1: Creating a flow from a set of ATs</em></p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/fm-gui1.png"><img alt="FM GUI main window with a blank flow" src="_images/fm-gui1.png" style="width: 414.0px; height: 455.4px;" /></a>
</div>
<p><strong>Figure 5:</strong> This is the 2-pane window with a blank flow. When creating a flow,
ATs showing in the right-pane can be selected and added into the flow. The left
pane will display the ATs in the order of being added.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/fm-gui2.png"><img alt="FM GUI adding Ingest AT" src="_images/fm-gui2.png" style="width: 538.65px; height: 531.05px;" /></a>
</div>
<dl class="docutils">
<dt><strong>Figure 6:</strong> Ingest task is selected from the task list in the right-pane and Add button clicked. The popup window lets you set the parameters and keywords of the task.</dt>
<dd><ul class="first last simple">
<li><strong>Nickname</strong>: This input field is for the user assigned name of Ingest AT.</li>
<li><strong>Image File</strong>: The file name of input FITS image</li>
<li><strong>pbcorr</strong>: Applying a primary beam correction if True, select the checkbox to set it to True, otherwise False.</li>
<li><strong>mask</strong>: If a mask needs to be created, select the checkbox to set it to True.</li>
<li><strong>symlink</strong>: Select the checkbox if you want a symlink is kept to the fitsfile.</li>
</ul>
</dd>
</dl>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/fm-gui3.png"><img alt="FM GUI adding Moment AT" src="_images/fm-gui3.png" style="width: 519.92px; height: 535.44px;" /></a>
</div>
<dl class="docutils">
<dt><strong>Figure 7:</strong> Add Moment task by selecting Moment from the AT list then clicking Add button.</dt>
<dd><ul class="first last simple">
<li><strong>Nickname</strong>: The user defined task name for the Moment task</li>
<li><strong>Source AT</strong>: This is the AT that produces the input BDP(s) for the Moment task. It is the Ingest task added in Figure 6 in this case.</li>
<li><strong>cutoff</strong>: The lower cutoff level for each moment in terms of sigma, an entry for each moment can be given, or a single value can be given which will be applied to all moments. The default is 2.</li>
<li><strong>dmax</strong>: The upper cutoff level for all moments in terms of sigma. The default is 1000000</li>
<li><strong>sigma</strong>: The noise level to be used for calculating the cutoff values. Negative values indicate that the AT should compute the value. The default is -1.0</li>
<li><strong>outfile</strong>: The base name for the output Moment BDP(s).</li>
</ul>
</dd>
</dl>
<p><em>Use Case 2: Modifying the flow used to compute the ADMIT BDPs</em></p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/fm-gui4.png"><img alt="FM GUI modifying a flow" src="_images/fm-gui4.png" style="width: 429.64px; height: 469.2px;" /></a>
</div>
<p><strong>Figure 8:</strong> The flow either used in computing ADMIT BDPs at ALMA archive, or created by the user in Use Case 1, can be loaded into the viewer from the pull-down File menu for viewing or modification.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/fm-gui5.png"><img alt="FM GUI deleting an AT" src="_images/fm-gui5.png" style="width: 428.72px; height: 469.2px;" /></a>
</div>
<p><strong>Figure 9:</strong> The ATs shown in the left-pane can be deleted by selecting the AT, then clicking the Delete button. Once the Yes button on the confirmation popup window is clicked, the remove method of FlowManager object will be called to actually remove the AT and its downstream ATs, if there is any.</p>
<p>The modification of an AT&#8217;s parameters can be done similarly with the popup window as adding an AT in Use Case 1.</p>
</div>
<div class="section" id="other-features">
<h4>Other Features<a class="headerlink" href="#other-features" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt><em>Running a flow and generating Python script based on the flow</em></dt>
<dd>To run a flow, click the Run button on the right-pane of the two-pane window. The FlowManager object will validate the flow, create the python script, then execute it. The same script will be saved to the disk for later use.</dd>
<dt><em>Drawing a flow diagram generated by dot</em></dt>
<dd>During the construction of a flow, the FlowManager will fire a system call to the <em>dot</em> program (if it is available), every time when an AT is added, modified, or removed, to create the flow diagram, which can be viewed in the Flow Diagram drawing panel shown in Figure 10. This feature is optional since some operating systems, such as CentOS/RedHad Linux, do not have <em>dot</em> program, the graphing tool of GraphViz, installed as default package.</dd>
</dl>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/fm-gui6.png"><img alt="FM GUI drawing a flow diagram" src="_images/fm-gui6.png" style="width: 452.2px; height: 576.3px;" /></a>
</div>
<p><strong>Figure 10:</strong> This is the optional panel of the Workflow Viewer that displays a flow diagram generated by the <em>dot</em> program.</p>
</div>
<div class="section" id="the-gui-worker-classes">
<h4>The GUI Worker Classes<a class="headerlink" href="#the-gui-worker-classes" title="Permalink to this headline">¶</a></h4>
<p>When users interact with the GUI, we need some worker classes to respond and handle the user requests to get the work done. One such class is FlowManager, whose methods are called to perform the modification of the flow, such as adding or removing an AT, or to validate and run the flow. Figure 11 shows the underlying worker classes of the GUI that process the user requests and carry out the actual work.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/fm-gui7.png"><img alt="FM GUI worker classes" src="_images/fm-gui7.png" style="width: 448.8px; height: 312.8px;" /></a>
</div>
<dl class="docutils">
<dt><strong>Figure 11:</strong> Tkinter GUI and its worker classes</dt>
<dd><ul class="first last simple">
<li><em>Flow Manager</em> handles all the flow processing or runs a flow.</li>
<li><em>Dot Maker</em> creates the .dot file that is used by <em>dot</em> to create flow diagram image.</li>
<li><em>Script Generator</em> generates the Python script based on the flow and saves it.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="implementation-notes">
<h4>Implementation Notes<a class="headerlink" href="#implementation-notes" title="Permalink to this headline">¶</a></h4>
<p>The PhotoImage class of Tkinter, which is the class to display images, only accepts GIF or PGM/PPM images, therefor the png or jpg flow diagram generated by the <em>dot</em> program could not be drawn in a Tkinter panel, unless the diagram is converted to GIP format. To avoid installing external package for just altering image format, <em>matplotlib</em>, which is already included in CASA, may be adopted to implement the display panel.</p>
</div>
</div>
</div>
<div class="section" id="example-code">
<h2>Example Code<a class="headerlink" href="#example-code" title="Permalink to this headline">¶</a></h2>
<p>This is working example for milestone 2, which ingests a FITS file from
a combined Cycle 0+1 data for NGC 253 (Bolatto et al.), computes
some statistics and spectra for the cube, identifies lines, creates
line cubes, and derives moments. Everything is stored in an ADMIT
object, ready for recomputation and tuning of the results.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#! /usr/bin/env casarun</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#   admit4.py :  example flow to read in an ascii spectrum and run it through LineSegments and LineID</span>
<span class="c1">#                The spectrum needs freq (in GHz) in col1 and intensity (arbitrary units) in col5.</span>
<span class="c1">#</span>
<span class="c1">#   Usage:      $ADMIT/admit/test/admit4.py  [options] spectrum.tab</span>
<span class="c1">#</span>
<span class="c1">#   this will create a spectrum.admit directory with all the BDP&#39;s and associated data products inside.</span>
<span class="c1">#</span>
<span class="c1">#   Note that the current ADMIT will create files like testCubeSpectrum.tab, testCubeStats.tab and</span>
<span class="c1">#   testPVCorr.tab inside the .admit directory for you to run them through admit4.py</span>
<span class="c1">#</span>
<span class="c1">#   A typical run with 100 channels takes about 10&quot; (fair amount of casa overhead,</span>
<span class="c1">#   even though none is used here; cpu in the 3 tasks is only little over 4&quot;)</span>
<span class="c1">#</span>
<span class="c1">#   time $ADMIT/admit/test/admit4.py --alias x testCubeSpectrum.tab &gt; testCubeSpectrum.tab.log</span>
<span class="c1">#   7.584u 2.345s 0:10.15 97.7%	0+0k 0+2584io 0pf+0w</span>
<span class="c1">#   TIMING : Dtime: CubeSpectrum END [ 0.294537   0.4536109]</span>
<span class="c1">#   TIMING : Dtime: LineSegment END [ 2.14727     2.17343116]</span>
<span class="c1">#   TIMING : Dtime: LineID END [ 2.105823    2.14143705]</span>
<span class="c1">#</span>
<span class="c1">#   Options:</span>
<span class="c1">#   -a  alias          (doesn&#39;t actually work)</span>
<span class="c1">#   -r  apar_file</span>
<span class="c1">#   -o  output_dir</span>
<span class="c1">#   -s  stop_label</span>
<span class="c1">#</span>
<span class="c1">#   @todo  make it also understand bdp&#39;s</span>
<span class="c1">#</span>
<span class="c1"># =================================================================================================================</span>
<span class="c1"># python system modules</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">argparse</span> <span class="kn">as</span> <span class="nn">ap</span>

<span class="kn">import</span> <span class="nn">admit</span>

<span class="n">version</span>  <span class="o">=</span> <span class="s1">&#39;30-mar-2016&#39;</span>

<span class="c1">#  ===&gt;&gt;&gt; set some parameters for this run &lt;&lt;&lt;=================================================================</span>
<span class="c1">#</span>
<span class="c1">#  !!! do not change these defaults, these are meant to be our desired defaults    !!!</span>
<span class="c1">#  !!! in an ideal universe. Instead, use the commented section below to enable    !!!</span>
<span class="c1">#  !!! them, or add your favorites to some new value to experiment with.           !!!</span>


<span class="nb">file</span>     <span class="o">=</span> <span class="s1">&#39;&#39;</span>               <span class="c1"># the default FITS input name to be ingested (basename is used for apar file)</span>
<span class="n">alias</span>    <span class="o">=</span> <span class="s1">&#39;&#39;</span>               <span class="c1"># -a --alias : use a short alias instead of the possibly long basename?</span>
<span class="n">apar</span>     <span class="o">=</span> <span class="s1">&#39;&#39;</span>               <span class="c1"># -r --apar:   add this apar as well (file.apar is also checked for)</span>
<span class="n">out</span>      <span class="o">=</span> <span class="s1">&#39;&#39;</span>               <span class="c1"># -o --out:    alternative output admit name (instead of file.admit)</span>
<span class="n">stop</span>     <span class="o">=</span> <span class="s1">&#39;&#39;</span>               <span class="c1"># -s --stop:   early labeled bailout (&#39;ingest&#39;, ...)</span>

<span class="n">plot</span>     <span class="o">=</span> <span class="s1">&#39;t&#39;</span>              <span class="c1">#</span>
<span class="c1">#</span>
<span class="n">vlsr</span>     <span class="o">=</span> <span class="mf">0.0</span>              <span class="c1"># either set it below, or make get_vlsr() to work (else vlsr=0 will be used)</span>
<span class="n">plotmode</span> <span class="o">=</span> <span class="n">admit</span><span class="o">.</span><span class="n">PlotControl</span><span class="o">.</span><span class="n">BATCH</span> <span class="c1"># NOPLOT, BATCH, INTERACTIVE, SHOW_AT_END</span>
<span class="n">plottype</span> <span class="o">=</span> <span class="n">admit</span><span class="o">.</span><span class="n">PlotControl</span><span class="o">.</span><span class="n">PNG</span>   <span class="c1"># PNG, JPG, etc.</span>
<span class="n">loglevel</span> <span class="o">=</span> <span class="mi">10</span>               <span class="c1"># 10=DEBUG, 15=TIMING 20=INFO 30=WARNING 40=ERROR 50=FATAL</span>
<span class="c1">#</span>
<span class="n">doClean</span>  <span class="o">=</span> <span class="bp">True</span>
<span class="n">lineUID</span>  <span class="o">=</span> <span class="bp">False</span>            <span class="c1"># if True, this would run LineID(identifylines=False) [old relic]</span>
<span class="n">linepar</span>  <span class="o">=</span> <span class="p">()</span>               <span class="c1"># if set, (numsigma,minchan,maxgap)</span>
<span class="n">llsmooth</span> <span class="o">=</span> <span class="p">[]</span>               <span class="c1"># smooothing for LineSegment and LineID</span>
<span class="n">iterate</span>  <span class="o">=</span> <span class="bp">True</span>             <span class="c1">#</span>
<span class="n">csub</span>     <span class="o">=</span> <span class="bp">None</span>             <span class="c1"># or 0,1,2,....</span>
<span class="n">online</span>   <span class="o">=</span> <span class="bp">False</span>
<span class="n">tier1width</span> <span class="o">=</span> <span class="mf">0.0</span>            <span class="c1">#</span>
<span class="c1">#</span>
<span class="n">reflist</span>  <span class="o">=</span> <span class="s1">&#39;etc/co_lines.list&#39;</span>    <span class="c1"># pick one from $ADMIT/etc</span>
<span class="c1">#-----------------------------------------------------------------------------------------------------------------------</span>
<span class="c1">#-------------------- command line parsing -----------------------------------------------------------------------------</span>
<span class="c1">#                     @todo cannot overload casa, it parses first (e.g. -c)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">argv</span> <span class="o">=</span> <span class="n">admit</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">casa_argv</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>

<span class="n">parser</span> <span class="o">=</span> <span class="n">ap</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;Process a single FITS continuum and optional PB correction&#39;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-a&#39;</span><span class="p">,</span><span class="s1">&#39;--alias&#39;</span> <span class="p">,</span><span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Alias&#39;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-o&#39;</span><span class="p">,</span><span class="s1">&#39;--out&#39;</span>   <span class="p">,</span><span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Optional output admit directory basename, instead derived from file&#39;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-r&#39;</span><span class="p">,</span><span class="s1">&#39;--apar&#39;</span>  <span class="p">,</span><span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;ADMIT parameter file (in addition to &quot;file.apar&quot;&#39;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-s&#39;</span><span class="p">,</span><span class="s1">&#39;--stop&#39;</span>  <span class="p">,</span><span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;early bailout label&#39;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;file&#39;</span>         <span class="p">,</span><span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;FITSMap (or CASA image, or MIRIAD image)&#39;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--version&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;version&#39;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(prog)s</span><span class="s1"> &#39;</span> <span class="o">+</span> <span class="n">version</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">())</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span>   <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span> <span class="nb">file</span>   <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;alias&#39;</span><span class="p">]</span>  <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span> <span class="n">alias</span>  <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;alias&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;apar&#39;</span><span class="p">]</span>   <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span> <span class="n">apar</span>   <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;apar&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span>    <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span> <span class="n">out</span>    <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;stop&#39;</span><span class="p">]</span>   <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span> <span class="n">stop</span>   <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;stop&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="n">admit</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">assert_files</span><span class="p">([</span><span class="nb">file</span><span class="p">])</span>                <span class="c1"># this will halt the script if something doesn&#39;t exist</span>

<span class="c1">#if plot == &quot;f&quot;: </span>
<span class="c1">#    plotmode=admit.PlotControl.NONE</span>

<span class="c1">#-----------------------------------------------------------------------------------------------------------------------</span>
<span class="c1">#------------------------------------------------------- start of script -----------------------------------------------</span>

<span class="c1">#  announce version</span>
<span class="k">print</span> <span class="s1">&#39;ADMIT4: Version &#39;</span><span class="p">,</span><span class="n">version</span>

<span class="c1">#  do the work in a proper &quot;.admit&quot; directory</span>
<span class="n">adir</span> <span class="o">=</span>  <span class="n">admit</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">admit_dir</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">out</span><span class="p">)</span>
<span class="c1">#   dirty method, it really should check if adir is an admit directory</span>
<span class="k">if</span> <span class="n">doClean</span> <span class="ow">and</span> <span class="n">adir</span> <span class="o">!=</span> <span class="nb">file</span><span class="p">:</span>
    <span class="k">print</span> <span class="s2">&quot;Removing previous results from &quot;</span><span class="p">,</span><span class="n">adir</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm -rf </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">adir</span><span class="p">)</span>
    <span class="n">create</span><span class="o">=</span><span class="bp">True</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">create</span><span class="o">=</span><span class="bp">False</span>


<span class="c1"># parse apar file(s) first, overwriting local apar variables</span>
<span class="k">for</span> <span class="n">ap1</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;admit4.apar&#39;</span><span class="p">,</span> <span class="nb">file</span><span class="o">+</span><span class="s2">&quot;.apar&quot;</span><span class="p">,</span> <span class="n">apar</span><span class="p">]:</span>         <span class="c1"># loop over 3 possible apar files, set parameters</span>
    <span class="k">if</span> <span class="n">ap1</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">ap1</span><span class="p">):</span>
        <span class="k">print</span> <span class="s2">&quot;Found parameter file &quot;</span><span class="p">,</span><span class="n">ap1</span>
        <span class="nb">execfile</span><span class="p">(</span><span class="n">ap1</span><span class="p">)</span>
        
<span class="n">a</span> <span class="o">=</span> <span class="n">admit</span><span class="o">.</span><span class="n">Project</span><span class="p">(</span><span class="n">adir</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Testing ADMIT4 style pipeline - version </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">version</span><span class="p">,</span><span class="n">create</span><span class="o">=</span><span class="n">create</span><span class="p">,</span><span class="n">loglevel</span><span class="o">=</span><span class="n">loglevel</span><span class="p">)</span>

<span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">new</span><span class="p">:</span>
    <span class="k">print</span> <span class="s2">&quot;Starting a new ADMIT using &quot;</span><span class="p">,</span><span class="nb">file</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="s1">&#39;cp -a </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">adir</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">admit_dir</span><span class="o">=</span><span class="n">adir</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;admit4.apar&#39;</span><span class="p">,</span> <span class="nb">file</span><span class="o">+</span><span class="s2">&quot;.apar&quot;</span><span class="p">,</span> <span class="n">apar</span><span class="p">]:</span>         <span class="c1"># loop over 3 possible apar files</span>
        <span class="k">if</span> <span class="n">ap</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">ap</span><span class="p">):</span>
            <span class="k">print</span> <span class="s2">&quot;Found parameter file &quot;</span><span class="p">,</span><span class="n">ap</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;cp </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ap</span><span class="p">,</span><span class="n">adir</span><span class="p">))</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span> <span class="s2">&quot;All done, we just read an existing admit.xml and it should do nothing&quot;</span>
    <span class="k">print</span> <span class="s2">&quot;Use admit0.py to re-run inside of your admit directory&quot;</span>
    <span class="c1">#</span>
    <span class="n">a</span><span class="o">.</span><span class="n">fm</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dir</span><span class="p">()</span><span class="o">+</span><span class="s1">&#39;admit.dot&#39;</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="n">a</span><span class="o">.</span><span class="n">showsetkey</span><span class="p">()</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>      <span class="c1"># doesn&#39;t work in IPython!</span>

<span class="c1"># Default ADMIT plotting environment</span>
<span class="n">a</span><span class="o">.</span><span class="n">plotparams</span><span class="p">(</span><span class="n">plotmode</span><span class="p">,</span><span class="n">plottype</span><span class="p">)</span>

<span class="c1"># GenerateSpectrum</span>
<span class="c1"># here we use a little backdoor in GenerateSpectrum_AT that reads in</span>
<span class="c1"># a spectrum </span>
<span class="n">gs1</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">addtask</span><span class="p">(</span><span class="n">admit</span><span class="o">.</span><span class="n">GenerateSpectrum_AT</span><span class="p">(</span><span class="nb">file</span><span class="o">=</span><span class="nb">file</span><span class="p">,</span><span class="n">seed</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">))</span>
<span class="n">gstab1</span> <span class="o">=</span> <span class="p">(</span><span class="n">gs1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

<span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="s1">&#39;generate&#39;</span><span class="p">:</span>  <span class="n">a</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># LineSegment</span>
<span class="n">ls1</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">addtask</span><span class="p">(</span><span class="n">admit</span><span class="o">.</span><span class="n">LineSegment_AT</span><span class="p">(),[</span><span class="n">gstab1</span><span class="p">])</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linepar</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">a</span><span class="p">[</span><span class="n">ls1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;numsigma&#39;</span><span class="p">,</span><span class="n">linepar</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">a</span><span class="p">[</span><span class="n">ls1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;minchan&#39;</span><span class="p">,</span> <span class="n">linepar</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">a</span><span class="p">[</span><span class="n">ls1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;maxgap&#39;</span><span class="p">,</span>  <span class="n">linepar</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">a</span><span class="p">[</span><span class="n">ls1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;csub&#39;</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="n">csub</span><span class="p">])</span>
<span class="n">a</span><span class="p">[</span><span class="n">ls1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;iterate&#39;</span><span class="p">,</span><span class="n">iterate</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="n">ls1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;smooth&#39;</span><span class="p">,</span><span class="n">llsmooth</span><span class="p">)</span>
<span class="n">lstab1</span> <span class="o">=</span> <span class="p">(</span><span class="n">ls1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

<span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="s1">&#39;segment&#39;</span><span class="p">:</span>  <span class="n">a</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># LineID</span>
<span class="n">ll1</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">addtask</span><span class="p">(</span><span class="n">admit</span><span class="o">.</span><span class="n">LineID_AT</span><span class="p">(),[</span><span class="n">gstab1</span><span class="p">])</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linepar</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">a</span><span class="p">[</span><span class="n">ll1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;numsigma&#39;</span><span class="p">,</span><span class="n">linepar</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">a</span><span class="p">[</span><span class="n">ll1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;minchan&#39;</span><span class="p">,</span> <span class="n">linepar</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">a</span><span class="p">[</span><span class="n">ll1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;maxgap&#39;</span><span class="p">,</span>  <span class="n">linepar</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="k">if</span> <span class="n">lineUID</span><span class="p">:</span>
    <span class="n">a</span><span class="p">[</span><span class="n">ll1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;identifylines&#39;</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="n">ll1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;csub&#39;</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="n">csub</span><span class="p">])</span>
<span class="n">a</span><span class="p">[</span><span class="n">ll1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;iterate&#39;</span><span class="p">,</span><span class="n">iterate</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="n">ll1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;smooth&#39;</span><span class="p">,</span><span class="n">llsmooth</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="n">ll1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;vlsr&#39;</span><span class="p">,</span><span class="n">vlsr</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="n">ll1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;references&#39;</span><span class="p">,</span><span class="n">reflist</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="n">ll1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;online&#39;</span><span class="p">,</span><span class="n">online</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="n">ll1</span><span class="p">]</span><span class="o">.</span><span class="n">setkey</span><span class="p">(</span><span class="s1">&#39;tier1width&#39;</span><span class="p">,</span><span class="n">tier1width</span><span class="p">)</span>

<span class="n">lltab1</span> <span class="o">=</span> <span class="p">(</span><span class="n">ll1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># finish off !</span>
<span class="n">a</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">a</span><span class="o">.</span><span class="n">showsetkey</span><span class="p">(</span><span class="n">adir</span><span class="o">+</span><span class="s1">&#39;/admit.apar&#39;</span><span class="p">)</span>

</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="line-detection">
<span id="linedetection-design"></span><h2>Line Detection<a class="headerlink" href="#line-detection" title="Permalink to this headline">¶</a></h2>
<p>Line detection is a complex multi stage process. In ADMIT we have procedures
for both 1D and 2D line detection, but both follow the same basic recipe:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Smooth the data to reduce noise</li>
<li>Subtract continuum</li>
<li>Search for segments/sections of line emission</li>
<li>Look for features of interest (peak detection)</li>
<li>Compare features to search for patterns</li>
<li>Use patterns to look for any weaker features</li>
</ol>
</div></blockquote>
<p>LineID will offer switches to allow differing depths of processing. The lowest level being
just after step 3, essentially just a U-line finder. While ADMIT may offer different recipes
for finding lines (e.g. a rotating galaxy method, an outflow method, etc.), it must offer a
single generic method (the default) that is robust to as many different scenarios as possible.</p>
<p>Below are specific implementation details for both 1D and 2D cases</p>
<div class="section" id="dimensional-line-detection">
<h3>1-Dimensional Line Detection<a class="headerlink" href="#dimensional-line-detection" title="Permalink to this headline">¶</a></h3>
<p>The primary input for 1-Dimensional line detection will be the CubeStats_BDP. While CubeSpec_BDPs
and PVCOrr_BDPs
can be used as input, they only characterize the spectrum from a limited region, and can cause
the line detection algorithms to not detect all of the channels of a given line or to mis-identify
the line. Thus any given
CubeSpec_BDPs would be used as secondary line detection (e.g. blended lines in the CubeStats_BDP
may appear as completely separate lines in individual spectra).
The specific data used from the CubeStats_BDP will be a spectrum that is the peak value of each channel
divided by the noise of the channel, giving a spectrum whose units are sigma, and a spectrum of the minimum value
of a channel over the noise of that channel, allowing for the detection of absorption lines.
All detection work will be done on both of these input spectra as a default.</p>
<div class="section" id="filtering">
<h4>Filtering<a class="headerlink" href="#filtering" title="Permalink to this headline">¶</a></h4>
<p>In order to reduce the noise and enhance any lines a filter (smoothing) can be applied
to the spectrum. ADMIT offers several different filters that can be applied,
these are located in admit/util/filter/Filter1D.py. The currently available filters
are: Gaussian, Welch, Hanning, Triangle, Boxcar, and Savitzgy-Golay. Since filters
are generally simple to implement they are all encased in a single class: Filter1D.
The class signature takes the spectrum, which method to use, and the arguments for
each filter.</p>
<p>Details of the different filter keywords and defaults:</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="19%" />
<col width="8%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Filter</th>
<th class="head">Keyword</th>
<th class="head">Def.</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8220;boxcar&#8221;</td>
<td>&#8220;width&#8221;</td>
<td>3</td>
<td>Number of channels to average together</td>
</tr>
<tr class="row-odd"><td>&#8220;gaussian&#8221;</td>
<td>&#8220;width&#8221;</td>
<td>7</td>
<td>Number of channels to span with the Gaussian</td>
</tr>
<tr class="row-even"><td>&#8220;hanning&#8221;</td>
<td>&#8220;width&#8221;</td>
<td>5</td>
<td>Number of channels to include in the cos</td>
</tr>
<tr class="row-odd"><td>&#8220;triangle&#8221;</td>
<td>&#8220;width&#8221;</td>
<td>5</td>
<td>Number of channels to span with the triangle</td>
</tr>
<tr class="row-even"><td>&#8220;welch&#8221;</td>
<td>&#8220;width&#8221;</td>
<td>5</td>
<td>Number of channels to use in the function</td>
</tr>
<tr class="row-odd"><td>&#8220;savgol&#8221;</td>
<td>&#8220;window_size&#8221;</td>
<td>7</td>
<td>Number of channels to use in the calculation</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&#8220;order&#8221;</td>
<td>3</td>
<td>Order of the polynomial fit (must be odd)</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&#8220;deriv&#8221;</td>
<td>0</td>
<td>The number of the derivative to compute
(0 = just smooth)</td>
</tr>
</tbody>
</table>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Raw_Spec.png"><img alt="_images/Raw_Spec.png" src="_images/Raw_Spec.png" style="width: 568.4px; height: 428.4px;" /></a>
</div>
<table border="1" class="borderless docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="first reference internal image-reference" href="_images/Savgol.png"><img alt="_images/Savgol.png" class="align-center" src="_images/Savgol.png" style="width: 649.6px; height: 489.6px;" /></a>
<p class="last">Savitzgy-Golay smoothed spectrum</p>
</td>
<td><a class="first reference internal image-reference" href="_images/Box.png"><img alt="_images/Box.png" class="align-center" src="_images/Box.png" style="width: 649.6px; height: 489.6px;" /></a>
<p class="last">Boxcar smoothed spectrum</p>
</td>
</tr>
<tr class="row-even"><td><a class="first reference internal image-reference" href="_images/Gauss.png"><img alt="_images/Gauss.png" class="align-center" src="_images/Gauss.png" style="width: 649.6px; height: 489.6px;" /></a>
<p class="last">Gaussian smoothed spectrum</p>
</td>
<td><a class="first reference internal image-reference" href="_images/Hanning.png"><img alt="_images/Hanning.png" class="align-center" src="_images/Hanning.png" style="width: 649.6px; height: 489.6px;" /></a>
<p class="last">Hanning smoothed spectrum</p>
</td>
</tr>
<tr class="row-odd"><td><a class="first reference internal image-reference" href="_images/Triangle.png"><img alt="_images/Triangle.png" class="align-center" src="_images/Triangle.png" style="width: 649.6px; height: 489.6px;" /></a>
<p class="last">Triangle smoothed spectrum</p>
</td>
<td><a class="first reference internal image-reference" href="_images/Welch.png"><img alt="_images/Welch.png" class="align-center" src="_images/Welch.png" style="width: 649.6px; height: 489.6px;" /></a>
<p class="last">Welch smoothed spectrum</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Additional filters can be added to the class using the following method:</dt>
<dd><ul class="first last simple">
<li>add the method to the class, the method can assume that the raw spectrum will be in self.spec
as a numpy array, and should return a numpy array of the same length with the filtered spectrum</li>
<li>add the method name to the self.methods list</li>
<li>add a self.&lt;method_name&gt;_args dictionary that contains the arguments and their default values</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="continuum-subtraction">
<h4>Continuum Subtraction<a class="headerlink" href="#continuum-subtraction" title="Permalink to this headline">¶</a></h4>
<p>Proper continuum subtraction is necessary to get reliable fits to the peak intensity and width of
the spectral lines. It must be performed on the CubeStats based spectrum, but is optional on
CubeSpectrum based spectra, although the algorithms should be robust enough to do no harm if
applied to spectra that have no continuum. The basic algorithm is to search for emission/absorption
features, mask them out and fit the remaining data with a line/curve. There are currently two
continuum subtraction algorithms.</p>
<p><strong>SplineFit</strong></p>
<p>The SplineFit algorithm fits a spline to the input masked spectrum. The order of the spline can be
given as an argument or the algorithm can search for the best fit order based on a chi-squared
analysis. The arguments are</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="14%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Def.</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>search</td>
<td>False</td>
<td>Whether or not to search for the best fit.</td>
</tr>
<tr class="row-odd"><td>bbox</td>
<td>None</td>
<td>2-sequence specifying the boundary of the approximation
interval. If None (default), bbox=[x[0], x[-1]]</td>
</tr>
<tr class="row-even"><td>k</td>
<td>3</td>
<td>1 &lt; k &lt;= 5, the degree of spline smoothing to use.</td>
</tr>
<tr class="row-odd"><td>s</td>
<td>None</td>
<td>Positive smoothing factor used to choose the number of knots.
If None (default), s = len(w), where 1/<code class="docutils literal"><span class="pre">w[i]</span></code> is an estimate of
the standard deviation of <code class="docutils literal"><span class="pre">y[i]</span></code>.</td>
</tr>
<tr class="row-even"><td>ext</td>
<td>0</td>
<td>Controls the extrapolation mode for elements not in the interval
defined by the knot sequence.</td>
</tr>
<tr class="row-odd"><td>check_finite</td>
<td>False</td>
<td>Whether to check that the input arrays contain only finite
numbers.</td>
</tr>
</tbody>
</table>
<p><strong>PolyFit</strong></p>
<p>The PolyFit algorithm fits a polynomial to the input masked spectrum. The order of the polynomial
can be controlled as an input parameter, or the algorithm can search for the best fit order based on
a chi-squared analysis. The arguments are</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="14%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Def.</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>search</td>
<td>False</td>
<td>Whether or not to search for the best fit.</td>
</tr>
<tr class="row-odd"><td>deg</td>
<td>1</td>
<td>The degree of polynomial to use.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="segment-detection">
<h4>Segment Detection<a class="headerlink" href="#segment-detection" title="Permalink to this headline">¶</a></h4>
<p>Segement detection is the most basic part of line identification. It identifies sections of channels
that are above a specified cutoff level, these sections must also have more than a given number of
contiguous channels in order to be counted. Currently we have two different methods of segment
detection: one from the ASAP package, and one from ASTUTE. It is likely that we will only need one
algorithm for segment detection, so both need to be thoroughly tested for robustness in the following
circumstances:</p>
<blockquote>
<div><ul class="simple">
<li>emission and absorption features</li>
<li>weak signal in high noise</li>
<li>strong signal with low noise</li>
</ul>
</div></blockquote>
<p>The output of the segment detection is a list of pairs of channels, with each pair indicating
the beginning and ending channels of a segment.</p>
</div>
<div class="section" id="peak-detection">
<h4>Peak Detection<a class="headerlink" href="#peak-detection" title="Permalink to this headline">¶</a></h4>
<p>Peak detection will happen in several stages. If both a CubeStats and CubeSpec BDPs are
supplied to the LineID_AT then peak detection would happen on the CubeStats first, as this is
the most likely one to show any type of global pattern(s). Any patterns found would then be applied
to any spectra from the CubeSpec_BDP.</p>
<p>There are currently two different peak finding algorithms in ADMIT: PeakUtils, and FindPeaksCWT. All
peak finding algorithms are located in admit.util.peakfind, and are expected to return a list of
peak positions from the input spectrum. Since peak finders are notably more complex than filters
each algorithm is in its own class and file. The user will be able to select which one(s) to use.
If multiple algorithms are specified then the results can be unioned or intersected, depending on
the specified preference. Any method used must be robust to both peaks (positive) and troughs (negative).
Any peak finding algorithm will return a list of peak positions.
Once a list of peaks is generated it will be compared to the detected segments and any peaks not
inside of a segment will be discarded as false/noise peaks.</p>
<p><strong>PeakFinder</strong></p>
<p>The PeakFinder algorithm searches for spectral peaks by taking the first derivative of the
spectrum and looks for zero crossings. Noise spikes are eliminated by
a noise cutoff, minimum separation of points, and minimum width of lines.</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="14%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Def.</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>spec</td>
<td>&nbsp;</td>
<td>The input spectrum as a numpy array</td>
</tr>
<tr class="row-odd"><td>x</td>
<td>&nbsp;</td>
<td>The x co-ordinates of the spectrum</td>
</tr>
<tr class="row-even"><td>thres</td>
<td>&nbsp;</td>
<td>The threshold to use for detecting a peak, currently this is
[0.,1.] of the peak intensity, but should be converted to either
a sigma or absolute flux value.</td>
</tr>
<tr class="row-odd"><td>min_sep</td>
<td>5</td>
<td>Minimum distance (in channels) between peaks.</td>
</tr>
<tr class="row-even"><td>min_width</td>
<td>5</td>
<td>Minimum distance (in channels) between peaks.</td>
</tr>
</tbody>
</table>
<p><strong>PeakUtils</strong></p>
<p>The PeakUtils algorithm has a two pass algorithm for detecting peaks. The first pass calculates the
differential of each point, along with minimum amplitude and spacing inputs, to locate the peaks.
The second pass takes the output of the first pass and refines the peak locations by fitting either a Gaussian
or Lorentzian profile to the data. This algorithm also has the ability to remove a baseline from
the spectrum for a better fit, which is useful since the peak/rms CubeStats spectra will have an artificial
&#8220;continuum&#8221;. Input parameters:</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="14%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Def.</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>spec</td>
<td>&nbsp;</td>
<td>The input spectrum as a numpy array</td>
</tr>
<tr class="row-odd"><td>x</td>
<td>&nbsp;</td>
<td>The x co-ordinates of the spectrum</td>
</tr>
<tr class="row-even"><td>thres</td>
<td>&nbsp;</td>
<td>The threshold to use for detecting a peak, currently this is
[0.,1.] of the peak intensity, but should be converted to either
a sigma or absolute flux value.</td>
</tr>
<tr class="row-odd"><td>min_dist</td>
<td>5</td>
<td>Minimum distance (in channels) between peaks.</td>
</tr>
<tr class="row-even"><td>profile</td>
<td>&#8220;gaussian&#8221;</td>
<td>Which profile to use for refining the peak locations. Choices are
&#8220;gaussian&#8221; and &#8220;lorentzian&#8221;.</td>
</tr>
<tr class="row-odd"><td>width</td>
<td>10</td>
<td>the number of channels on either side of a peak to use when
refining a peak location.</td>
</tr>
<tr class="row-even"><td>basedeg</td>
<td>3</td>
<td>The order of the polynomial to use for baseline subtraction.</td>
</tr>
<tr class="row-odd"><td>baseiter</td>
<td>100</td>
<td>The maximum number of iterations to perform when trying to fit
the baseline.</td>
</tr>
<tr class="row-even"><td>basetol</td>
<td>1e-3</td>
<td>Tolerance to use when iterating to find the best baseline fit.</td>
</tr>
<tr class="row-odd"><td>dobase</td>
<td>False</td>
<td>Whether or not to do baseline subtraction, should be set to True
when processing CubeStat data as it has a &#8220;continuum&#8221;.</td>
</tr>
</tbody>
</table>
<p><strong>FindPeaksCWT</strong></p>
<p>The FindPeaksCWT is a wrapper for the SciPy Continuous Wavelet Transform peak finder.</p>
<p>Input parameters:</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="14%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Def.</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>spec</td>
<td>&nbsp;</td>
<td>The input spectrum as a numpy array</td>
</tr>
<tr class="row-odd"><td>x</td>
<td>&nbsp;</td>
<td>The x co-ordinates of the spectrum</td>
</tr>
<tr class="row-even"><td>widths</td>
<td>&nbsp;</td>
<td>A 1D array of widths to use to calculate the CWT matrix.</td>
</tr>
<tr class="row-odd"><td>wavelet</td>
<td>None</td>
<td>Which wavelet to use (default is actually the ricker wavelet)</td>
</tr>
<tr class="row-even"><td>max_distances</td>
<td>widths/4.</td>
<td>Range of distances to use for finding individual and ridges of
peaks.</td>
</tr>
<tr class="row-odd"><td>gap_thresh</td>
<td><ol class="first last arabic simple" start="5">
<li></li>
</ol>
</td>
<td>How far relative peaks can be before a ridgeline is stopped.</td>
</tr>
<tr class="row-even"><td>min_length</td>
<td>1/4 #widths</td>
<td>Minimum length a ridgeline needs to be.</td>
</tr>
<tr class="row-odd"><td>min_snr</td>
<td>3</td>
<td>Minimum SNR.</td>
</tr>
<tr class="row-even"><td>noise_perc</td>
<td>10</td>
<td>Percentage of data points below which is considered noise.</td>
</tr>
</tbody>
</table>
<p>Additional peak finding algorithms can be added in admit/util/peakfind by following these guidelines</p>
<blockquote>
<div><ul class="simple">
<li>A class whose signature __init__ is as sketched below.
This allows for a constant calling signature and aids in the plug and play nature of the peak finder</li>
<li>The class must define a &#8220;find&#8221; method that takes no arguments and which returns a list of peaks</li>
<li>Any additional methods are up to the developer</li>
<li>Add a self.&lt;class_name&gt;_args dictionary that contains the arguments and their default values
to LineID_AT</li>
<li>Add the class name to the LineID.methods list</li>
</ul>
</div></blockquote>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">spec</span><span class="p">,</span><span class="n">x</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwarg</span><span class="p">):</span>
</pre></div>
</div>
</div>
<div class="section" id="pattern-matching">
<h4>Pattern Matching<a class="headerlink" href="#pattern-matching" title="Permalink to this headline">¶</a></h4>
<p>Once peak finding is complete LineID will look for patterns in the located peaks. Patterns are defined as
spectral features that are caused by the kinematics of the source (e.g. rotation, collapse, expansion, etc).
As an example take the following spectrum where peak finding located 5 distinct peaks.</p>
<div class="figure align-center" id="id12">
<a class="reference internal image-reference" href="_images/peakfind.png"><img alt="_images/peakfind.png" src="_images/peakfind.png" style="width: 640.0px; height: 480.0px;" /></a>
<p class="caption"><span class="caption-text">Example spectrum showing 5 peaks detected.</span></p>
</div>
<p>LineID will calculate the distances between all pairs of peaks: 1-&gt;2, 1-&gt;3, 1-&gt;4, 1-&gt;5, 2-&gt;3, 2-&gt;4, ...
From these results the AT will look for distinct pairs of lines that are the same distance
apart, within a small margin of error. In this instance the pairs 2-&gt;3 and 4-&gt;5 would meet the criteria.
The AT would then determine that there is a pattern to at least some of the spectral features (this would require at least
two distinct pairs of lines to determine). Once this determination is made the AT will assume that the
center between the peaks is the correct line frequency (labeled &#8220;c&#8221; on the below plot).</p>
<div class="figure align-center" id="id13">
<a class="reference internal image-reference" href="_images/peakfind2.png"><img alt="_images/peakfind2.png" src="_images/peakfind2.png" style="width: 640.0px; height: 480.0px;" /></a>
<p class="caption"><span class="caption-text">Example spectrum with 5 peaks and 2 central frequencies noted.</span></p>
</div>
<p>For these pairs of lines only the central frequency (&#8220;c&#8221;) will be considered for trying to identify the line.
The velocity offsets of the two peaks will be retained for subsequent spectra. For any subsequent spectra
(e.g. from CubeSpec), or any lines not part of the pattern (line 1 in this case) LineID would consider any
of the three velocities (systemic, lower offset, and upper offset) to be possible frequencies for the purpose
of identifying the line, as some spectral lines may only appear in one of the velocity
components. Any peak finding and pattern matching algorithms will have to be robust to both standard rotation
profiles, P-Cygni, inverse P-Cygni, and pairs of absorption lines.</p>
<p>Note that pattern finding can become problematic if there are too many lines in a given spectrum. In
these instances false patterns can be detected. A threshold was determined through thorough
experimantation above which pattern finding will have too great a chance of finding false patterns.
The experiments involved creating noise spectra with differing numbers of channels (500 - 20,000), injecting
Gaussian line profiles (between 5 and 100) randomly into the spectra, and running the segment finder,
peak finder, and parrern finder on them. Then the number of patterns found in each spectra was
determined, since all peaks were random there should be 0. This was run 100 times for each spectrum
size. It was decided to make a cutoff when the pattern finder found a false pattern no more than 25%
of the time. The figure below shows this point for each of the spectral sizes. The x axis is the
number of channels in the spectrum and the y axis is the number of peaks which form a false pattern
25% of the time. The red curve is from experimentation and the black curve is the best fit.
If the number of peaks in a given spectrum falls above the curve (hatched area) then
the pattern finder will turn itself off, unless it is forced on.</p>
<div class="figure align-center" id="id14">
<a class="reference internal image-reference" href="_images/pattern_cut.png"><img alt="_images/pattern_cut.png" src="_images/pattern_cut.png" style="width: 1814.4px; height: 1136.8px;" /></a>
<p class="caption"><span class="caption-text">Plot of the number of peaks vs the number of channels in a spectrum. The red curve represents
the point above which palse patterns are detected at least 25% of the time. The black curve
is the best fit to these points.</span></p>
</div>
<p>Using a type of cross-correlation to do pattern matching was considered. Testing showed that the shape of the result
was very dependent on the number of features in the spectrum and was more complex than the original spectrum. The
result when a double peaked spectrum was cross-correlated was very similar to when a spectrum with a mix of double
and single peaked features was used.</p>
</div>
</div>
<div class="section" id="id4">
<h3>2-Dimensional Line Detection<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>All discussion on 2D line detection have been postponed until the PVCorr_AT is complete.</p>
<div class="section" id="id5">
<h4>Filtering<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>In order to reduce the noise and enhance any lines a 2D filter can be applied
to the PvSlice. ADMIT offers several different 2-Dimensional filters that can be applied,
these are located in admit/util/filter/Filter2D.py. The currently available filters
are: Gaussian, Welch, Hanning, Triangle, Boxcar, and Savitzgy-Golay. Since filters
are generally simple to implement they are all encased in a single class: Filter2D.
The class signature takes the spectrum, which method to use, and the arguments for
each filter.</p>
<p>Details of the different filter keywords and defaults:</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="19%" />
<col width="8%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Filter</th>
<th class="head">Keyword</th>
<th class="head">Def.</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8220;boxcar&#8221;</td>
<td>&#8220;width&#8221;</td>
<td>5</td>
<td>Number of channels to average together</td>
</tr>
<tr class="row-odd"><td>&#8220;gaussian&#8221;</td>
<td>&#8220;width&#8221;</td>
<td>9</td>
<td>Number of channels to span with the Gaussian</td>
</tr>
<tr class="row-even"><td>&#8220;hanning&#8221;</td>
<td>&#8220;width&#8221;</td>
<td>7</td>
<td>Number of channels to include in the cos</td>
</tr>
<tr class="row-odd"><td>&#8220;triangle&#8221;</td>
<td>&#8220;width&#8221;</td>
<td>7</td>
<td>Number of channels to span with the triangle</td>
</tr>
<tr class="row-even"><td>&#8220;welch&#8221;</td>
<td>&#8220;width&#8221;</td>
<td>7</td>
<td>Number of channels to use in the function</td>
</tr>
<tr class="row-odd"><td>&#8220;savgol&#8221;</td>
<td>&#8220;window_size&#8221;</td>
<td>11</td>
<td>Number of channels to use in the calculation</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&#8220;order&#8221;</td>
<td>3</td>
<td>Order of the polynomial fit (must be odd)</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&#8220;deriv&#8221;</td>
<td>None</td>
<td>The number of the derivative to compute
(None = just smooth)</td>
</tr>
</tbody>
</table>
<div class="figure align-center" id="id15">
<a class="reference internal image-reference" href="_images/Raw_Map2D.png"><img alt="_images/Raw_Map2D.png" src="_images/Raw_Map2D.png" style="width: 565.6px; height: 183.2px;" /></a>
<p class="caption"><span class="caption-text">The raw image</span></p>
</div>
<table border="1" class="borderless docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="first reference internal image-reference" href="_images/Savgol2D.png"><img alt="_images/Savgol2D.png" class="align-center" src="_images/Savgol2D.png" style="width: 715.0px; height: 229.0px;" /></a>
<p class="last">Savitzgy-Golay smoothed image</p>
</td>
<td><a class="first reference internal image-reference" href="_images/Box2D.png"><img alt="_images/Box2D.png" class="align-center" src="_images/Box2D.png" style="width: 706.0px; height: 242.0px;" /></a>
<p class="last">Boxcar smoothed image</p>
</td>
</tr>
<tr class="row-even"><td><a class="first reference internal image-reference" href="_images/Gauss2D.png"><img alt="_images/Gauss2D.png" class="align-center" src="_images/Gauss2D.png" style="width: 719.0px; height: 238.0px;" /></a>
<p class="last">Gaussian smoothed image</p>
</td>
<td><a class="first reference internal image-reference" href="_images/Hanning2D.png"><img alt="_images/Hanning2D.png" class="align-center" src="_images/Hanning2D.png" style="width: 709.0px; height: 223.0px;" /></a>
<p class="last">Hanning smoothed image</p>
</td>
</tr>
<tr class="row-odd"><td><a class="first reference internal image-reference" href="_images/Triangle2D.png"><img alt="_images/Triangle2D.png" class="align-center" src="_images/Triangle2D.png" style="width: 712.0px; height: 227.0px;" /></a>
<p class="last">Triangle smoothed image</p>
</td>
<td><a class="first reference internal image-reference" href="_images/Welch2D.png"><img alt="_images/Welch2D.png" class="align-center" src="_images/Welch2D.png" style="width: 715.0px; height: 223.0px;" /></a>
<p class="last">Welch smoothed image</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Additional filters can be added to the class using the following method:</dt>
<dd><ul class="first last simple">
<li>add the method to the class, the method can assume that the raw image will be in self.data as a
numpy array, and should return a numpy array of the same dimensions with the filtered image</li>
<li>add the method name to the self.methods list</li>
<li>add a self.&lt;method_name&gt;_args dictionary that contains the arguments and their default values</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="id6">
<h4>Peak Detection<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>There are several 2 Dimensional peak finding algorithms already in python and they are still being investigated</p>
</div>
<div class="section" id="id7">
<h4>Pattern Matching<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>This is likely the purview of PVCorr:
Pattern matching in the 2-D case is similar to the 1-D case in that the LineID_AT will be searching for
similar patterns of emission/absorption. Once peaks are located in the map the emission regions, defined to be
any contiguous region with emission above a given threshold, will be determined. A spline will be constructed
that describes the ridge of peak emission (an &#8220;S&#8221; shape in the case of rotation). This spline will then be
convolved across the map looking for strong correlations</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/pattern.png"><img alt="_images/pattern.png" src="_images/pattern.png" style="width: 572.0px; height: 179.2px;" /></a>
</div>
<p>These strong correlations will indicate spectral lines. The central peak or the center between the strongest peak
on the spline and any correlations will be considered the correct rest frequency for the line(s).</p>
</div>
</div>
<div class="section" id="line-identification">
<h3>Line Identification<a class="headerlink" href="#line-identification" title="Permalink to this headline">¶</a></h3>
<p>Line identification is a multi-stage process. Once peaks are located their locations are compared
to the Tier 1 list of molecules. The Tier 1 list of molcules contains the transitions of molecules
that if present, are expected to be a dominant emission peak in the spectrum. The allowed
frequency/velocity ranges for these transitions are relaxed compared to those of others. In gneneral
any peak detected within 30 km/s (galactic source) and 200 km/s (extragalactic source) of a Tier 1
rest frequency will be assigned the identification of that transition. Additionally, the identified
peak is traced down to the cutoff level and any additional peaks found along the way are also labeled
the Tier 1 transition. Tier 1 molecules are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Molecule</th>
<th class="head">Constraints</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CO</td>
<td>31.0 - 950.0 GHz</td>
</tr>
<tr class="row-odd"><td>13CO</td>
<td>31.0 - 950.0 GHz</td>
</tr>
<tr class="row-even"><td>C17O</td>
<td>31.0 - 950.0 GHz</td>
</tr>
<tr class="row-odd"><td>HCO+</td>
<td>31.0 - 950.0 GHz</td>
</tr>
<tr class="row-even"><td>HDO</td>
<td>31.0 - 950.0 GHz</td>
</tr>
<tr class="row-odd"><td>CCH</td>
<td>31.0 - 950.0 GHz, HFL</td>
</tr>
<tr class="row-even"><td>CN</td>
<td>31.0 - 950.0 GHz, HFL, weakest lines eliminated</td>
</tr>
<tr class="row-odd"><td>HCN</td>
<td>31.0 - 950.0 GHz, HFL</td>
</tr>
<tr class="row-even"><td>HNC</td>
<td>31.0 - 950.0 GHz</td>
</tr>
<tr class="row-odd"><td>13CN</td>
<td>31.0 - 950.0 GHz, HFL, weakest lines eliminated</td>
</tr>
<tr class="row-even"><td>H13CN</td>
<td>31.0 - 950.0 GHz, HFL</td>
</tr>
<tr class="row-odd"><td>HN13C</td>
<td>31.0 - 950.0 GHz</td>
</tr>
<tr class="row-even"><td>N2H+</td>
<td>31.0 - 950.0 GHz, HFL</td>
</tr>
<tr class="row-odd"><td>C18O&#8221;</td>
<td>31.0 - 950.0 GHz</td>
</tr>
<tr class="row-even"><td>H13CO+</td>
<td>31.0 - 950.0 GHz</td>
</tr>
<tr class="row-odd"><td>DCO+</td>
<td>31.0 - 950.0 GHz</td>
</tr>
<tr class="row-even"><td>H2CO</td>
<td>31.0 - 950.0 GHz, weakest lines eliminated, limited to Eu &lt; 200 K</td>
</tr>
<tr class="row-odd"><td>DCN</td>
<td>31.0 - 950.0 GHz, HFL</td>
</tr>
<tr class="row-even"><td>CS</td>
<td>31.0 - 950.0 GHz</td>
</tr>
<tr class="row-odd"><td>SiO</td>
<td>31.0 - 950.0 GHz</td>
</tr>
<tr class="row-even"><td>SO</td>
<td>31.0 - 950.0 GHz, weakest lines eliminated</td>
</tr>
<tr class="row-odd"><td>HC3N</td>
<td>31.0 - 950.0 GHz, HFL, weakest lines eliminated</td>
</tr>
<tr class="row-even"><td>13CS</td>
<td>31.0 - 950.0 GHz</td>
</tr>
<tr class="row-odd"><td>C34S</td>
<td>31.0 - 950.0 GHz</td>
</tr>
</tbody>
</table>
<p>HFL indicates hyperfine lines, these transitions are treated specially in that only
the strongest hyperfine line is searched for initially. If that line is found then
the rest of the hyperfine components are searched for.</p>
<p>Once any Tier 1 lines have been identified, the frequency of the remaining peaks
are used to search for possible identifications with the slsearch tool. The frequency
range is determined by fiting a Gaussian to the peak and getting the FWHM of the line.
This value is used for the frequency range given to slsearch.</p>
<p>From the list of potential identifications from slsearch, the best identifiation is
determined by comparing the upper state energies of the transitions, the number
of non-standard isotopes in the molecules (13C would be considered non-standard, while
12C would be considered standard), and the molecular weights. The &#8220;winner&#8221; is usually
the one with the lowest energy, unless it has a high mass compared to other possible
molecules, or has a large number of non-standard isotopes. This precess will likely
be refined as we move forward. If no potential identifications are returned by
slsearch then the line is marked as Unidentified.</p>
<div class="section" id="tier-1-database">
<h4>Tier 1 Database<a class="headerlink" href="#tier-1-database" title="Permalink to this headline">¶</a></h4>
<p>The Tier 1 lines are stored in an SqLite database that is queryable via the Tier1DB
class. The data are in two tables, one for the transitions with no hyperfine components
and strongest hyperfine components, and one for the weaker hyperfine components associated
with the stronger ones. The columns of the Transitions table are as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="9%" />
<col width="15%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Units</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SPECIES</td>
<td>STRING</td>
<td>None</td>
<td>The chemical formula.</td>
</tr>
<tr class="row-odd"><td>NAME</td>
<td>STRING</td>
<td>None</td>
<td>The name of the molecule.</td>
</tr>
<tr class="row-even"><td>FREQUENCY</td>
<td>REAL</td>
<td>GHz</td>
<td>The transition frequency.</td>
</tr>
<tr class="row-odd"><td>QUANTUM_NUMBERS</td>
<td>STRING</td>
<td>None</td>
<td>The quantum numbers of the transition.</td>
</tr>
<tr class="row-even"><td>LINE_STR</td>
<td>REAL</td>
<td>Debye^2</td>
<td>The transition line strength.</td>
</tr>
<tr class="row-odd"><td>LOWER_ENERGY</td>
<td>REAL</td>
<td>K</td>
<td>The lower state energy of the transition.</td>
</tr>
<tr class="row-even"><td>UPPER_ENERGY</td>
<td>REAL</td>
<td>K</td>
<td>The upper state energy of the transition.</td>
</tr>
<tr class="row-odd"><td>HFS</td>
<td>INT</td>
<td>None</td>
<td>The key for locating any related hyperfine lines
in the HFC table.</td>
</tr>
</tbody>
</table>
<p>The columns of the HFC table are as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="9%" />
<col width="15%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Units</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>TRANSITION</td>
<td>INT</td>
<td>None</td>
<td>Key linking the hyperfine components of a single
transition together.</td>
</tr>
<tr class="row-odd"><td>FREQUENCY</td>
<td>REAL</td>
<td>GHz</td>
<td>Hyperfine component frequency.</td>
</tr>
<tr class="row-even"><td>QUANTUM_NUMBERS</td>
<td>STRING</td>
<td>None</td>
<td>Hyperfine transition quantum numbers.</td>
</tr>
<tr class="row-odd"><td>LINE_STR</td>
<td>REAL</td>
<td>Debye^2</td>
<td>Hyperfine transition line strength.</td>
</tr>
<tr class="row-even"><td>LOWER_ENERGY</td>
<td>REAL</td>
<td>K</td>
<td>Hyperfine transition lower state energy.</td>
</tr>
<tr class="row-odd"><td>UPPER_ENERGY</td>
<td>REAL</td>
<td>K</td>
<td>Hyperfine transition upper state energy.</td>
</tr>
</tbody>
</table>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">admit.util.Tier1DB</span> <span class="k">import</span> <span class="n">Tier1DB</span>
<span class="n">t1db</span> <span class="o">=</span> <span class="n">Tier1DB</span><span class="p">()</span>
</pre></div>
</div>
<p>The database can be querried either with the searchtransitions method or, for the expert
user, the query method. The searchtransitions method takes numerous parameters to constrain
the frequency range, energy range, line strength, and species name. See the <a class="reference internal" href="module/admit.util/Tier1DB.html#tier1db-api"><span class="std std-ref">Tier1DB &#8212; Tier 1 molecular line database services.</span></a> API
for details on the parameters. The query method takes a single string, containing an SQL query,
as a parameter.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">t1db</span><span class="o">.</span><span class="n">searchtransitions</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="p">[</span><span class="mf">100.0</span><span class="p">,</span><span class="mf">102.0</span><span class="p">])</span>  <span class="c1"># searches between 100.0 and 102.0 GHz</span>
</pre></div>
</div>
<p>The results of the query are stored internally in the class and can be returned
with the get, getone, or getall methods. The getone and getall methods return a single
result (the next one in the list) or all results, respectively. The get method takes
a single parameter, an integer specifying how many results to return. The return values
are a list (or a list of lists in the case of get (n&gt;1) or getall). Each element in the list
are an entry from the database columns. In the case of the query method, the number and type
of columns are dependednt on the specifics of the query string. For the searchtransitions
method the returned list will have seven entries, one for each of the columns in the above
Transitions table.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="n">t1db</span><span class="o">.</span><span class="n">getall</span><span class="p">()</span>
</pre></div>
</div>
<p>The results can be iterated over:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
    <span class="nb">print</span> <span class="n">r</span>
</pre></div>
</div>
<p>If any transition has associated hyperfine components the value of the HFS column (column
8 from the searchtransitions method) will be non-zero, the actual value indicating the
index for the HFC table. The hyperfine components can be retrieved with the searchhfc
method, which takes a single parameter, the HFS key.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">t1db</span><span class="o">.</span><span class="n">searchhfc</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
        <span class="n">hfc</span> <span class="o">=</span> <span class="n">t1db</span><span class="o">.</span><span class="n">getall</span><span class="p">()</span>
</pre></div>
</div>
<p>The results returned are a list of lists, each inner list containing an entry from columns
2-6 of the above HFC table. Note that the class only holds the results from the most recent
query, so it is recommended that the results of a query are fully retrieved before initiating
another query.</p>
</div>
<div class="section" id="identification-confidence">
<h4>Identification Confidence<a class="headerlink" href="#identification-confidence" title="Permalink to this headline">¶</a></h4>
<p>Each identified line will have an associated confidence level that indicates how sure
the system is of the identificaiton. The confidence level will be specified as a
percentage, with 100% being full confidence and 0% being no confidence, though no line will have
either 100% confidence or 0% confidence. Every identification will start at 50% and will
have a range of 5%-95%. The following table describes any modifiers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="86%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Mod.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>It is a tier 1 line</td>
<td>+40%</td>
</tr>
<tr class="row-odd"><td>Segment overlaps another line</td>
<td>-20%</td>
</tr>
<tr class="row-even"><td>Segment overlaps a tier 1 line</td>
<td>-40%</td>
</tr>
<tr class="row-odd"><td>Hyperfine components/torsional components also ID&#8217;d*</td>
<td>+20%</td>
</tr>
<tr class="row-even"><td>Missing hyperfine components/torsional components*</td>
<td>-20%</td>
</tr>
<tr class="row-odd"><td>Identified in multiple inputs (spec, stats, pvcorr)</td>
<td>+15% ea.</td>
</tr>
</tbody>
</table>
<p>*additional code not in the AT will be needed to determine this.</p>
<p>Unidentified lines will not have a confidence level.</p>
</div>
</div>
</div>
<div class="section" id="the-summary">
<h2>The Summary<a class="headerlink" href="#the-summary" title="Permalink to this headline">¶</a></h2>
<p>Each ADMIT object contains a summary of the data, ATs, and BDPs that it
contains, stored in a <a class="reference internal" href="module/admit/Summary.html#summary-api"><span class="std std-ref">Summary &#8212; Project summary metadata.</span></a> Summary object.
The Summary defines and manages the summary metadata for the ADMIT object, which is ingested by ALMA Archive and also used by data browser.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Design Overview</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#admit-tasks">ADMIT Tasks</a></li>
<li><a class="reference internal" href="#basic-data-products">Basic Data Products</a></li>
<li><a class="reference internal" href="#the-admit-object">The ADMIT object</a></li>
<li><a class="reference internal" href="#admit-i-o-system">ADMIT I/O System</a></li>
<li><a class="reference internal" href="#workflow-management">Workflow Management</a></li>
<li><a class="reference internal" href="#architecture-overview">Architecture Overview</a><ul>
<li><a class="reference internal" href="#bdp-infrastructure">BDP Infrastructure</a></li>
<li><a class="reference internal" href="#task-infrastructure">Task Infrastructure</a></li>
<li><a class="reference internal" href="#utilities">Utilities</a></li>
<li><a class="reference internal" href="#toolkit-infrastructure">Toolkit Infrastructure</a></li>
<li><a class="reference internal" href="#user-interfaces">User Interfaces</a></li>
</ul>
</li>
<li><a class="reference internal" href="#base-classes">Base Classes</a><ul>
<li><a class="reference internal" href="#at-base-class">AT Base Class</a></li>
<li><a class="reference internal" href="#bdp-base-class">BDP Base Class</a></li>
<li><a class="reference internal" href="#table-base-class">Table Base Class</a></li>
<li><a class="reference internal" href="#image-base-class">Image Base Class</a></li>
<li><a class="reference internal" href="#line-base-class">Line Base Class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#individual-at-designs">Individual AT Designs</a><ul>
<li><a class="reference internal" href="#file-at">File_AT</a></li>
<li><a class="reference internal" href="#flow-at">Flow_AT</a></li>
<li><a class="reference internal" href="#ingest-at">Ingest_AT</a></li>
<li><a class="reference internal" href="#cubespectrum-at">CubeSpectrum_AT</a></li>
<li><a class="reference internal" href="#cubestats-at">CubeStats_AT</a></li>
<li><a class="reference internal" href="#cubesum-at">CubeSum_AT</a></li>
<li><a class="reference internal" href="#featurelist-at">FeatureList_AT</a></li>
<li><a class="reference internal" href="#lineid-at">LineID_AT</a></li>
<li><a class="reference internal" href="#linecube-at">LineCube_AT</a></li>
<li><a class="reference internal" href="#linesegment-at">LineSegment_AT</a></li>
<li><a class="reference internal" href="#pvslice-at">PVSlice_AT</a></li>
<li><a class="reference internal" href="#pvcorr-at">PVCorr_AT</a></li>
<li><a class="reference internal" href="#peakpointplot-at">PeakPointPlot_AT</a></li>
<li><a class="reference internal" href="#moment-at">Moment_AT</a></li>
<li><a class="reference internal" href="#overlapintegral-at">OverlapIntegral_AT</a></li>
<li><a class="reference internal" href="#smooth-at">Smooth_AT</a></li>
<li><a class="reference internal" href="#regrid-at">Regrid_AT</a></li>
</ul>
</li>
<li><a class="reference internal" href="#individual-bdp-designs">Individual BDP Designs</a><ul>
<li><a class="reference internal" href="#table-bdp">Table_BDP</a></li>
<li><a class="reference internal" href="#image-bdp">Image_BDP</a></li>
<li><a class="reference internal" href="#line-bdp">Line_BDP</a></li>
<li><a class="reference internal" href="#linelist-bdp">LineList_BDP</a></li>
<li><a class="reference internal" href="#linecube-bdp">LineCube_BDP</a></li>
<li><a class="reference internal" href="#moment-bdp">Moment_BDP</a></li>
<li><a class="reference internal" href="#spwcube-bdp">SpwCube_BDP</a></li>
<li><a class="reference internal" href="#cubespectrum-bdp">CubeSpectrum_BDP</a></li>
<li><a class="reference internal" href="#cubestats-bdp">CubeStats_BDP</a></li>
<li><a class="reference internal" href="#pvcorr-bdp">PVCorr_BDP</a></li>
</ul>
</li>
<li><a class="reference internal" href="#logging-infrastructure">Logging Infrastructure</a></li>
<li><a class="reference internal" href="#graphical-user-interface-design">Graphical User Interface Design</a><ul>
<li><a class="reference internal" href="#bdp-viewer-design">BDP Viewer Design</a><ul>
<li><a class="reference internal" href="#implementation-details">Implementation Details</a></li>
</ul>
</li>
<li><a class="reference internal" href="#workflow-viewer-design">Workflow Viewer Design</a><ul>
<li><a class="reference internal" href="#use-cases">Use Cases</a></li>
<li><a class="reference internal" href="#other-features">Other Features</a></li>
<li><a class="reference internal" href="#the-gui-worker-classes">The GUI Worker Classes</a></li>
<li><a class="reference internal" href="#implementation-notes">Implementation Notes</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#example-code">Example Code</a></li>
<li><a class="reference internal" href="#line-detection">Line Detection</a><ul>
<li><a class="reference internal" href="#dimensional-line-detection">1-Dimensional Line Detection</a><ul>
<li><a class="reference internal" href="#filtering">Filtering</a></li>
<li><a class="reference internal" href="#continuum-subtraction">Continuum Subtraction</a></li>
<li><a class="reference internal" href="#segment-detection">Segment Detection</a></li>
<li><a class="reference internal" href="#peak-detection">Peak Detection</a></li>
<li><a class="reference internal" href="#pattern-matching">Pattern Matching</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">2-Dimensional Line Detection</a><ul>
<li><a class="reference internal" href="#id5">Filtering</a></li>
<li><a class="reference internal" href="#id6">Peak Detection</a></li>
<li><a class="reference internal" href="#id7">Pattern Matching</a></li>
</ul>
</li>
<li><a class="reference internal" href="#line-identification">Line Identification</a><ul>
<li><a class="reference internal" href="#tier-1-database">Tier 1 Database</a></li>
<li><a class="reference internal" href="#identification-confidence">Identification Confidence</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#the-summary">The Summary</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="installguide.html"
                        title="previous chapter">Installation Guide</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="style.html"
                        title="next chapter">Documentation Style Guide</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/design.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="style.html" title="Documentation Style Guide"
             >next</a> |</li>
        <li class="right" >
          <a href="installguide.html" title="Installation Guide"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">ADMIT 1.0.6 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, The ADMIT Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.8.
    </div>
  </body>
</html>