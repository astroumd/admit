#! /usr/bin/env python
#
#   Example python script that for a given PID (e.g. 2018.1.01115.S) descends in the Sous/Gous/Mous trees
#   and finds all {cube,mfs} pbcor.fits files, and runs a suite of predefined ADMIT recipes on them
#   in a directory parallel to product, named admit.
#
#   So, for existing          PID/Sous/Gous/Mous/product/
#   it will work inside       PID/Sous/Gous/Mous/admit/
#
#   Notes:
#      1. this is still for old-style admit, not ADMIT3
#      2. this does not encode the different tree view that is encoded in the old do_aap5
#      3. it handles *.pb.fits as well as *.pb.fits.gz files that should mirror the *.pbcor.fits files
#
#   @todo     encode variants on the recipes (binning, numsigma)

import os, sys
import glob

try:
    import casa
    print("Warning: still assuming classic ADMIT")
    is_admit3 = False
except:
    try:
        import casatasks    # pre-release now does this????
        is_admit3 = True
        print("Good news: running ADMIT3")
    except:
        print("Bad news: your python doesn't know casa or casatasks")

    
def usage():
    print("Usage: %s PID(s)")
    print("For one or more PID's find the pbcor.fits files that are needed for 'runa1' and 'runa2' in ADMIT")
    sys.exit(0)

def splitall(path):
    """
        Taken from https://www.oreilly.com/library/view/python-cookbook/0596001673/ch04s16.html
    """
    allparts = []
    while 1:
        parts = os.path.split(path)
        if parts[0] == path:  # sentinel for absolute paths
            allparts.insert(0, parts[0])
            break
        elif parts[1] == path: # sentinel for relative paths
            allparts.insert(0, parts[1])
            break
        else:
            path = parts[0]
            allparts.insert(0, parts[1])
    return allparts

def find_pbcor(pid, mfs=False, cube=False, verbose=False):
    """
    find the pbcor files. Currently limits to "mfs" and/or "cube"
    """
    product = glob.glob('%s/*/*/*/product' % pid)
    if len(product) == 0:
        # a cheat
        if pid == 'product':
            product = ['product']
        else:
            pids = splitall(pid)
            print("PJT",pids)
            if pids[-1] == 'product':
                product = [pid]
            else:
                print("No product tree found in %s" % pid)
                print("Need a valid Project ID directory name")
                return []

    pbcor = []
    for p in product:
        w = p.split('/')
        if len(w) > 4:
            sous = w[-4]
            gous = w[-3]
            mous = w[-2]
            if verbose:
                print("PID : %s   \nSOUS: %s    \nGOUS: %s    \nMOUS: %s" % (pid,sous,gous,mous))
            
        if cube:
            pbcor1 = glob.glob('%s/*_sci*.cube.I.pbcor.fits' % p)
            for p1 in pbcor1:
                if verbose:
                    print(p1)
                pbcor.append(p1)
        if mfs:
            pbcor2 = glob.glob('%s/*_sci*.mfs.I.pbcor.fits' % p)
            for p2 in pbcor2:
                if verbose:
                    print(p2)
                pbcor.append(p2)
    return pbcor

def runa1(pbcorname,pbname=None,label=None,apars=[],dryrun=False):
    """ the runa1 recipe, with optional extra args
        $ADMIT/admit/test/admit2.py --pb fname.pb.fits.gz --basename x --out fname.<label>.admit --apar fname.<label>.apar   fname.pbcor.fits
    e.g.   runa1(fname, "native.5sigma", ["numsigma=5"])
           runa1(fname, "binned16.3sigma", ["insmooth=-16","numsigma=5"])
    """
    r = '$ADMIT/admit/test/admit1.py'
    r = r + ' --pb %s' % pbname
    r = r + ' --basename x'
    if len(apars) > 0:
        if label == None:
            aparname = pbcorname + '.apar'
        else:
            aparname = pbcorname.replace('.fits','') + '.%s.apar' % label
        fp = open(aparname,"w")
        fp.write("# written by AAP\n")
        for apar in apars:
            fp.write("%s\n" % apar)
        fp.close()
        r = r + ' --apar %s' % aparname
    if label == None:
        outname =  pbcorname.replace('.fits','') + ".admit"
    else:
        outname =  pbcorname.replace('.fits','') + '.%s.admit' % label
    r = r + ' --out %s' % outname
    r = r + ' %s' % pbcorname
    r = r + ' > %s.log 2>&1' % outname
    print(r)
    if not dryrun:
        os.system(r)

def runa2(pbcorname,pbname=None,label=None,apars=[],dryrun=False):
    """ the runa1 recipe, with optional extra args
        $ADMIT/admit/test/admit2.py --pb fname.pb.fits.gz --basename x --out fname.<label>.admit --apar fname.<label>.apar   fname.pbcor.fits
    e.g.   runa1(fname, "native.5sigma", ["numsigma=5"])
           runa1(fname, "binned16.3sigma", ["insmooth=-16","numsigma=5"])

           pbcorname = basename.pbcor.fits
           outname   = basename.pbcor.admit      or basename.pbcor.<label>.admit
           aparname  = basename.pbcor.fits.apar  or basename.pbcor.<label>.apar
    """
    r = '$ADMIT/admit/test/admit2.py'
    r = r + ' --pb %s' % pbname
    r = r + ' --basename x'
    if len(apars) > 0:
        if label == None:
            aparname = pbcorname + '.apar'
        else:
            aparname = pbcorname.replace('.fits','') + '.%s.apar' % label
        fp = open(aparname,"w")
        fp.write("# written by AAP\n")
        for apar in apars:
            fp.write("%s\n" % apar)
        fp.close()
        r = r + ' --apar %s' % aparname
    if label == None:
        outname =  pbcorname.replace('.fits','') + ".admit"
    else:
        outname =  pbcorname.replace('.fits','') + '.%s.admit' % label
    r = r + ' --out %s' % outname
    r = r + ' %s' % pbcorname
    r = r + ' > %s.log 2>&1' % outname
    print(r)
    if not dryrun:
        os.system(r)


def run_admit(recipe, pbcor, dryrun=False, verbose=False):
    """ based on a full pbcor file run a recipe in a directory parallel to product
            [dir/]product/basename.mfs.I.pbcor.fits       runa1
            [dir/]product/basename.cube.I.pbcor.fits      runa2
        A directory name before 'product' is optional, but recommended
    """ 
    idx = pbcor.find('.pbcor.fits')
    pb = glob.glob(pbcor[:idx] + '.pb.fits*')
    if len(pb) == 0:
        print("Warning: no matching pb found for %s" % pbcor)
        return
    pb = pb[0]
    if verbose:
        print(pbcor)
        print(pb)
    #  e.g. PID/S/G/M/product/member.uid___A001_X133f_X1a2.Tile_004_SMC_SWBar_sci.spw22.cube.I.pbcor.fits
    #                 product/member.uid___A001_X133f_X1a2.Tile_004_SMC_SWBar_sci.spw22.cube.I.pbcor.fits
    pbname = splitall(pb)[-1]
    d = splitall(pbcor)
    pbcorname = d[-1]
    pdir = '/'.join(d[:-1])
    adir = '/'.join(d[:-2]) + '/admit'
    if verbose:
        print(adir)
    #    now some horrid file operations which can possible be done more efficiently if I had a better toolkit
    cmd = 'mkdir -p %s' % adir
    if not dryrun:
        os.system(cmd)
        cwd = os.getcwd()
        os.chdir(adir)
        os.system('ln -sf ../product/%s' % pbcorname)
        os.system('ln -sf ../product/%s' % pbname)

    if recipe == 'runa2':
        runa2(pbcorname,pbname,dryrun=dryrun)
        runa2(pbcorname,pbname,"native.5sigma",["numsigma=3"],dryrun=dryrun)
    elif recipe == 'runa1':
        runa1(pbcorname,pbname,"native.5sigma",["numsigma=5"],dryrun=dryrun)
        runa1(pbcorname,pbname,"binned4.3sigma",["insmooth=-4","numsigma=3"],dryrun=dryrun)

    if not dryrun:
        os.chdir(cwd)

if len(sys.argv) == 1:
    usage()




if __name__ == "__main__":

    # Project ID, below which there is (at least one) Sous/Gous/Mous
    pid = sys.argv[1]
    verbose = False
    dryrun = True

    p1 = find_pbcor(pid,cube=True, verbose=verbose)
    print("Found %d cube pbcor fits files for ADMIT to process" % len(p1))
    p2 = find_pbcor(pid,mfs=True, verbose=verbose)
    print("Found %d msf pbcor fits files for ADMIT to process" % len(p2))


    if True:
        # the cheap continuum maps
        for p in p2:
            run_admit('runa2', p, verbose=verbose, dryrun=dryrun)

        # the expensive cubes
        for p in p1:
            run_admit('runa1', p, verbose=verbose, dryrun=dryrun)
    else:
        run_admit('runa2', p2[0], verbose=verbose,dryrun=dryrun)
        run_admit('runa1', p1[0], verbose=verbose,dryrun=dryrun)


